"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
/**
 * Specifies various transformations that will be performed by Span.getModifiedText().
 */
var SpanModification = (function () {
    function SpanModification(span) {
        this.span = span;
        this.reset();
    }
    Object.defineProperty(SpanModification.prototype, "prefix", {
        /**
         * Allows the Span.prefix text to be changed.
         */
        get: function () {
            return this._prefix !== undefined ? this._prefix : this.span.prefix;
        },
        set: function (value) {
            this._prefix = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpanModification.prototype, "suffix", {
        /**
         * Allows the Span.suffix text to be changed.
         */
        get: function () {
            return this._suffix !== undefined ? this._suffix : this.span.suffix;
        },
        set: function (value) {
            this._suffix = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reverts any modifications made to this object.
     */
    SpanModification.prototype.reset = function () {
        this.skipChildren = false;
        this.skipSeparatorAfter = false;
        this._prefix = undefined;
        this._suffix = undefined;
    };
    /**
     * Effectively deletes the Span from the tree, by skipping its children, skipping its separator,
     * and setting its prefix/suffix to the empty string.
     */
    SpanModification.prototype.skipAll = function () {
        this.prefix = '';
        this.suffix = '';
        this.skipChildren = true;
        this.skipSeparatorAfter = true;
    };
    return SpanModification;
}());
exports.SpanModification = SpanModification;
/**
 * The Span class provides a simple way to rewrite TypeScript source files
 * based on simple syntax transformations, i.e. without having to process deeper aspects
 * of the underlying grammar.  An example transformation might be deleting JSDoc comments
 * from a source file.
 *
 * @remarks
 * Technically, TypeScript's abstract syntax tree (AST) is represented using Node objects.
 * The Node text ignores its surrounding whitespace, and does not have an ordering guarantee.
 * For example, a JSDocComment node can be a child of a FunctionDeclaration node, even though
 * the actual comment precedes the function in the input stream.
 *
 * The Span class is a wrapper for a single Node, that provides access to every character
 * in the input stream, such that Span.getText() will exactly reproduce the corresponding
 * full Node.getText() output.
 *
 * A Span is comprised of these parts, which appear in sequential order:
 * - A prefix
 * - A collection of child spans
 * - A suffix
 * - A separator (e.g. whitespace between this span and the next item in the tree)
 *
 * These parts can be modified via Span.modification.  The modification is applied by
 * calling Span.getModifiedText().
 */
var Span = (function () {
    function Span(node) {
        this.node = node;
        this.startIndex = node.getStart();
        this.endIndex = node.end;
        this.separatorStartIndex = 0;
        this.separatorEndIndex = 0;
        this.children = [];
        this.modification = new SpanModification(this);
        var previousChildSpan = undefined;
        for (var _i = 0, _a = this.node.getChildren() || []; _i < _a.length; _i++) {
            var childNode = _a[_i];
            var childSpan = new Span(childNode);
            this.children.push(childSpan);
            // Normalize the bounds so that a child is never outside its parent
            if (childSpan.startIndex < this.startIndex) {
                this.startIndex = childSpan.startIndex;
            }
            if (childSpan.endIndex > this.endIndex) {
                // This has never been observed empirically, but here's how we would handle it
                this.endIndex = childSpan.endIndex;
                throw new Error('Unexpected AST case');
            }
            if (previousChildSpan) {
                if (previousChildSpan.endIndex < childSpan.startIndex) {
                    // There is some leftover text after previous child -- assign it as the separator for
                    // the preceding span.  If the preceding span has no suffix, then assign it to the
                    // deepest preceding span with no suffix.  This heuristic simplifies the most
                    // common transformations, and otherwise it can be fished out using getLastInnerSeparator().
                    var separatorRecipient = previousChildSpan;
                    while (separatorRecipient.children.length > 0) {
                        var lastChild = separatorRecipient.children[separatorRecipient.children.length - 1];
                        if (lastChild.endIndex !== separatorRecipient.endIndex) {
                            // There is a suffix, so we cannot push the separator any further down, or else
                            // it would get printed before this suffix.
                            break;
                        }
                        separatorRecipient = lastChild;
                    }
                    separatorRecipient.separatorStartIndex = previousChildSpan.endIndex;
                    separatorRecipient.separatorEndIndex = childSpan.startIndex;
                }
            }
            previousChildSpan = childSpan;
        }
    }
    Span._modifyHelper = function (callback, spans, parentSpan) {
        var previousSpan = undefined;
        for (var _i = 0, spans_1 = spans; _i < spans_1.length; _i++) {
            var span = spans_1[_i];
            callback(span, previousSpan, parentSpan);
            if (!span.modification.skipChildren) {
                Span._modifyHelper(callback, span.children, span);
            }
            previousSpan = span;
        }
    };
    Object.defineProperty(Span.prototype, "kind", {
        get: function () {
            return this.node.kind;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "prefix", {
        /**
         * The text associated with the underlying Node, up to its first child.
         */
        get: function () {
            if (this.children.length) {
                // Everything up to the first child
                return this._getSubstring(this.startIndex, this.children[0].startIndex);
            }
            else {
                return this._getSubstring(this.startIndex, this.endIndex);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "suffix", {
        /**
         * The text associated with the underlying Node, after its last child.
         * If there are no children, this is always an empty string.
         */
        get: function () {
            if (this.children.length) {
                // Everything after the last child
                return this._getSubstring(this.children[this.children.length - 1].endIndex, this.endIndex);
            }
            else {
                return '';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "separator", {
        /**
         * Whitespace that appeared after this node, and before the "next" node in the tree.
         * Here we mean "next" according to an inorder traversal, not necessarily a sibling.
         */
        get: function () {
            return this._getSubstring(this.separatorStartIndex, this.separatorEndIndex);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the separator of this Span, or else recursively calls getLastInnerSeparator()
     * on the last child.
     */
    Span.prototype.getLastInnerSeparator = function () {
        if (this.separator) {
            return this.separator;
        }
        if (this.children.length > 0) {
            return this.children[this.children.length - 1].getLastInnerSeparator();
        }
        return '';
    };
    /**
     * Recursively invokes the callback on this Span and all its children.  The callback
     * can make changes to Span.modification for each node.  If SpanModification.skipChildren
     * is true, those children will not be processed.
     */
    Span.prototype.modify = function (callback) {
        Span._modifyHelper(callback, [this], undefined);
    };
    /**
     * Returns the original unmodified text represented by this Span.
     */
    Span.prototype.getText = function () {
        var result = '';
        result += this.prefix;
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            result += child.getText();
        }
        result += this.suffix;
        result += this.separator;
        return result;
    };
    /**
     * Returns the text represented by this Span, after applying all requested modifications.
     */
    Span.prototype.getModifiedText = function () {
        var result = '';
        result += this.modification.prefix;
        if (!this.modification.skipChildren) {
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                result += child.getModifiedText();
            }
        }
        result += this.modification.suffix;
        if (!this.modification.skipSeparatorAfter) {
            result += this.separator;
        }
        return result;
    };
    /**
     * Returns a diagnostic dump of the tree, showing the prefix/suffix/separator for
     * each node.
     */
    Span.prototype.getDump = function (indent) {
        if (indent === void 0) { indent = ''; }
        var result = indent + ts.SyntaxKind[this.node.kind] + ': ';
        if (this.prefix) {
            result += ' pre=[' + this._getTrimmed(this.prefix) + ']';
        }
        if (this.suffix) {
            result += ' suf=[' + this._getTrimmed(this.suffix) + ']';
        }
        if (this.separator) {
            result += ' sep=[' + this._getTrimmed(this.separator) + ']';
        }
        result += '\n';
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            result += child.getDump(indent + '  ');
        }
        return result;
    };
    Span.prototype._getTrimmed = function (text) {
        var trimmed = text.replace(/[\r\n]/g, '\\n');
        if (trimmed.length > 100) {
            return trimmed.substr(0, 97) + '...';
        }
        return trimmed;
    };
    Span.prototype._getSubstring = function (startIndex, endIndex) {
        if (startIndex === endIndex) {
            return '';
        }
        return this.node.getSourceFile().text.substring(startIndex, endIndex);
    };
    return Span;
}());
exports.Span = Span;

//# sourceMappingURL=Span.js.map
