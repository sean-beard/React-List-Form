{"version":3,"sources":["generators/Span.ts"],"names":[],"mappings":"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","file":"generators/Span.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\n\r\n/**\r\n * Callback for Span.modify()\r\n */\r\nexport type SpanModifyCallback = (span: Span, previousSpan: Span | undefined, parentSpan: Span | undefined) => void;\r\n\r\n/**\r\n * Specifies various transformations that will be performed by Span.getModifiedText().\r\n */\r\nexport class SpanModification {\r\n  public skipChildren: boolean;\r\n  public skipSeparatorAfter: boolean;\r\n\r\n  private readonly span: Span;\r\n  private _prefix: string | undefined;\r\n  private _suffix: string | undefined;\r\n\r\n  public constructor(span: Span) {\r\n    this.span = span;\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Allows the Span.prefix text to be changed.\r\n   */\r\n  public get prefix(): string {\r\n    return this._prefix !== undefined ? this._prefix : this.span.prefix;\r\n  }\r\n\r\n  public set prefix(value: string) {\r\n    this._prefix = value;\r\n  }\r\n\r\n  /**\r\n   * Allows the Span.suffix text to be changed.\r\n   */\r\n  public get suffix(): string {\r\n    return this._suffix !== undefined ? this._suffix : this.span.suffix;\r\n  }\r\n\r\n  public set suffix(value: string) {\r\n    this._suffix = value;\r\n  }\r\n\r\n  /**\r\n   * Reverts any modifications made to this object.\r\n   */\r\n  public reset(): void {\r\n    this.skipChildren = false;\r\n    this.skipSeparatorAfter = false;\r\n    this._prefix = undefined;\r\n    this._suffix = undefined;\r\n  }\r\n\r\n  /**\r\n   * Effectively deletes the Span from the tree, by skipping its children, skipping its separator,\r\n   * and setting its prefix/suffix to the empty string.\r\n   */\r\n  public skipAll(): void {\r\n    this.prefix = '';\r\n    this.suffix = '';\r\n    this.skipChildren = true;\r\n    this.skipSeparatorAfter = true;\r\n  }\r\n}\r\n\r\n/**\r\n * The Span class provides a simple way to rewrite TypeScript source files\r\n * based on simple syntax transformations, i.e. without having to process deeper aspects\r\n * of the underlying grammar.  An example transformation might be deleting JSDoc comments\r\n * from a source file.\r\n *\r\n * @remarks\r\n * Technically, TypeScript's abstract syntax tree (AST) is represented using Node objects.\r\n * The Node text ignores its surrounding whitespace, and does not have an ordering guarantee.\r\n * For example, a JSDocComment node can be a child of a FunctionDeclaration node, even though\r\n * the actual comment precedes the function in the input stream.\r\n *\r\n * The Span class is a wrapper for a single Node, that provides access to every character\r\n * in the input stream, such that Span.getText() will exactly reproduce the corresponding\r\n * full Node.getText() output.\r\n *\r\n * A Span is comprised of these parts, which appear in sequential order:\r\n * - A prefix\r\n * - A collection of child spans\r\n * - A suffix\r\n * - A separator (e.g. whitespace between this span and the next item in the tree)\r\n *\r\n * These parts can be modified via Span.modification.  The modification is applied by\r\n * calling Span.getModifiedText().\r\n */\r\nexport class Span {\r\n  public readonly node: ts.Node;\r\n\r\n  // To improve performance, substrings are not allocated until actually needed\r\n  public readonly startIndex: number;\r\n  public readonly endIndex: number;\r\n  public separatorStartIndex: number;\r\n  public separatorEndIndex: number;\r\n\r\n  public readonly children: Span[];\r\n\r\n  public readonly modification: SpanModification;\r\n\r\n  private static _modifyHelper(callback: SpanModifyCallback, spans: Span[], parentSpan: Span|undefined): void {\r\n    let previousSpan: Span|undefined = undefined;\r\n\r\n    for (const span of spans) {\r\n      callback(span, previousSpan, parentSpan);\r\n\r\n      if (!span.modification.skipChildren) {\r\n        Span._modifyHelper(callback, span.children, span);\r\n      }\r\n\r\n      previousSpan = span;\r\n    }\r\n  }\r\n\r\n  public constructor(node: ts.Node) {\r\n    this.node = node;\r\n    this.startIndex = node.getStart();\r\n    this.endIndex = node.end;\r\n    this.separatorStartIndex = 0;\r\n    this.separatorEndIndex = 0;\r\n    this.children = [];\r\n    this.modification = new SpanModification(this);\r\n\r\n    let previousChildSpan: Span = undefined;\r\n\r\n    for (const childNode of this.node.getChildren() || []) {\r\n      const childSpan: Span = new Span(childNode);\r\n      this.children.push(childSpan);\r\n\r\n      // Normalize the bounds so that a child is never outside its parent\r\n      if (childSpan.startIndex < this.startIndex) {\r\n        this.startIndex = childSpan.startIndex;\r\n      }\r\n\r\n      if (childSpan.endIndex > this.endIndex) {\r\n        // This has never been observed empirically, but here's how we would handle it\r\n        this.endIndex = childSpan.endIndex;\r\n        throw new Error('Unexpected AST case');\r\n      }\r\n\r\n      if (previousChildSpan) {\r\n        if (previousChildSpan.endIndex < childSpan.startIndex) {\r\n          // There is some leftover text after previous child -- assign it as the separator for\r\n          // the preceding span.  If the preceding span has no suffix, then assign it to the\r\n          // deepest preceding span with no suffix.  This heuristic simplifies the most\r\n          // common transformations, and otherwise it can be fished out using getLastInnerSeparator().\r\n          let separatorRecipient: Span = previousChildSpan;\r\n          while (separatorRecipient.children.length > 0) {\r\n            const lastChild: Span = separatorRecipient.children[separatorRecipient.children.length - 1];\r\n            if (lastChild.endIndex !== separatorRecipient.endIndex) {\r\n              // There is a suffix, so we cannot push the separator any further down, or else\r\n              // it would get printed before this suffix.\r\n              break;\r\n            }\r\n            separatorRecipient = lastChild;\r\n          }\r\n          separatorRecipient.separatorStartIndex = previousChildSpan.endIndex;\r\n          separatorRecipient.separatorEndIndex = childSpan.startIndex;\r\n        }\r\n      }\r\n\r\n      previousChildSpan = childSpan;\r\n    }\r\n  }\r\n\r\n  public get kind(): ts.SyntaxKind {\r\n    return this.node.kind;\r\n  }\r\n\r\n  /**\r\n   * The text associated with the underlying Node, up to its first child.\r\n   */\r\n  public get prefix(): string {\r\n    if (this.children.length) {\r\n      // Everything up to the first child\r\n      return this._getSubstring(this.startIndex, this.children[0].startIndex);\r\n    } else {\r\n      return this._getSubstring(this.startIndex, this.endIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The text associated with the underlying Node, after its last child.\r\n   * If there are no children, this is always an empty string.\r\n   */\r\n  public get suffix(): string {\r\n    if (this.children.length) {\r\n      // Everything after the last child\r\n      return this._getSubstring(this.children[this.children.length - 1].endIndex, this.endIndex);\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whitespace that appeared after this node, and before the \"next\" node in the tree.\r\n   * Here we mean \"next\" according to an inorder traversal, not necessarily a sibling.\r\n   */\r\n  public get separator(): string {\r\n    return this._getSubstring(this.separatorStartIndex, this.separatorEndIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns the separator of this Span, or else recursively calls getLastInnerSeparator()\r\n   * on the last child.\r\n   */\r\n  public getLastInnerSeparator(): string {\r\n    if (this.separator) {\r\n      return this.separator;\r\n    }\r\n    if (this.children.length > 0) {\r\n      return this.children[this.children.length - 1].getLastInnerSeparator();\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Recursively invokes the callback on this Span and all its children.  The callback\r\n   * can make changes to Span.modification for each node.  If SpanModification.skipChildren\r\n   * is true, those children will not be processed.\r\n   */\r\n  public modify(callback: SpanModifyCallback): void {\r\n    Span._modifyHelper(callback, [this], undefined);\r\n  }\r\n\r\n  /**\r\n   * Returns the original unmodified text represented by this Span.\r\n   */\r\n  public getText(): string {\r\n    let result: string = '';\r\n    result += this.prefix;\r\n\r\n    for (const child of this.children) {\r\n      result += child.getText();\r\n    }\r\n\r\n    result += this.suffix;\r\n    result += this.separator;\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the text represented by this Span, after applying all requested modifications.\r\n   */\r\n  public getModifiedText(): string {\r\n    let result: string = '';\r\n    result += this.modification.prefix;\r\n\r\n    if (!this.modification.skipChildren) {\r\n      for (const child of this.children) {\r\n        result += child.getModifiedText();\r\n      }\r\n    }\r\n\r\n    result += this.modification.suffix;\r\n    if (!this.modification.skipSeparatorAfter) {\r\n      result += this.separator;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump of the tree, showing the prefix/suffix/separator for\r\n   * each node.\r\n   */\r\n  public getDump(indent: string = ''): string {\r\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\r\n\r\n    if (this.prefix) {\r\n      result += ' pre=[' + this._getTrimmed(this.prefix) + ']';\r\n    }\r\n    if (this.suffix) {\r\n      result += ' suf=[' + this._getTrimmed(this.suffix) + ']';\r\n    }\r\n    if (this.separator) {\r\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\r\n    }\r\n    result += '\\n';\r\n\r\n    for (const child of this.children) {\r\n      result += child.getDump(indent + '  ');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private _getTrimmed(text: string): string {\r\n    const trimmed: string = text.replace(/[\\r\\n]/g, '\\\\n');\r\n\r\n    if (trimmed.length > 100) {\r\n      return trimmed.substr(0, 97) + '...';\r\n    }\r\n    return trimmed;\r\n  }\r\n\r\n  private _getSubstring(startIndex: number, endIndex: number): string {\r\n    if (startIndex === endIndex) {\r\n      return '';\r\n    }\r\n    return this.node.getSourceFile().text.substring(startIndex, endIndex);\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}