"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fsx = require("fs-extra");
var os = require("os");
var path = require("path");
var through = require("through2");
var gulpUtil = require("gulp-util");
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var api_extractor_1 = require("@microsoft/api-extractor");
var TypeScriptConfiguration_1 = require("./TypeScriptConfiguration");
var ts = require("gulp-typescript");
function writeStringToGulpUtilFile(content, filename) {
    if (filename === void 0) { filename = 'tempfile'; }
    return new gulpUtil.File({
        contents: new Buffer(content),
        path: filename
    });
}
/**
 * The ApiExtractorTask uses the api-extractor tool to analyze a project for public APIs. api-extractor will detect
 * common problems and generate a report of the exported public API. The task uses the entry point of a project to
 * find the aliased exports of the project. An api-extractor.ts file is generated for the project in the temp folder.
 * @public
 */
var ApiExtractorTask = (function (_super) {
    __extends(ApiExtractorTask, _super);
    function ApiExtractorTask() {
        return _super.call(this, 'api-extractor', {
            enabled: false,
            entry: undefined,
            apiReviewFolder: undefined,
            apiJsonFolder: undefined
        }) || this;
    }
    ApiExtractorTask.prototype.loadSchema = function () {
        return require('./schemas/api-extractor.schema.json');
    };
    ApiExtractorTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.taskConfig.enabled || !this._validateConfiguration()) {
            completeCallback();
            return;
        }
        if (!this.taskConfig.entry) {
            completeCallback('taskConfig.entry must be defined');
            return;
        }
        if (!this.taskConfig.apiJsonFolder) {
            completeCallback('taskConfig.apiJsonFolder must be defined');
            return;
        }
        if (!this.taskConfig.apiReviewFolder) {
            completeCallback('taskConfig.apiReviewFolder must be defined');
            return;
        }
        var entryPointFile = path.join(this.buildConfig.rootPath, this.taskConfig.entry);
        var typingsFilePath = path.join(this.buildConfig.rootPath, 'typings/tsd.d.ts');
        var otherFiles = fsx.existsSync(typingsFilePath) ? [typingsFilePath] : [];
        // tslint:disable-next-line:no-any
        var compilerOptions = TypeScriptConfiguration_1.TypeScriptConfiguration.getGulpTypescriptOptions(this.buildConfig).compilerOptions;
        if (compilerOptions.module !== 'commonjs' && compilerOptions.module) {
            this.logWarning("Your tsconfig.json file specifies a different \"target\" than expected. "
                + ("Expected: \"commonjs\". Actual: \"" + compilerOptions.module + "\". Using \"commonjs\" instead."));
            compilerOptions.module = 'commonjs';
        }
        var extractorOptions = {
            compilerOptions: ts.createProject(compilerOptions).options,
            errorHandler: function (message, fileName, lineNumber) {
                _this.logWarning("" + message + os.EOL
                    + ("  " + fileName + "#" + lineNumber));
            }
        };
        var analyzeOptions = {
            entryPointFile: entryPointFile,
            otherFiles: otherFiles
        }; /* tslint:disable-line:no-any */
        var extractor = new api_extractor_1.Extractor(extractorOptions);
        extractor.loadExternalPackages(path.join(__dirname, 'external-api-json'));
        extractor.analyze(analyzeOptions);
        var jsonGenerator = new api_extractor_1.ApiJsonGenerator();
        // const jsonContent: string = generator.generateJsonFileContent(analyzer);
        var jsonFileName = path.basename(this.buildConfig.rootPath) + '.api.json';
        if (!fsx.existsSync(this.taskConfig.apiJsonFolder)) {
            fsx.mkdirsSync(this.taskConfig.apiJsonFolder, function (err) {
                if (err) {
                    _this.logError("Could not create directory " + _this.taskConfig.apiJsonFolder);
                }
            });
        }
        if (fsx.existsSync(this.taskConfig.apiJsonFolder)) {
            var jsonFilePath = path.join(this.taskConfig.apiJsonFolder, jsonFileName);
            this.logVerbose("Writing Api JSON file to " + jsonFilePath);
            jsonGenerator.writeJsonFile(jsonFilePath, extractor);
        }
        var generator = new api_extractor_1.ApiFileGenerator();
        var actualApiFileContent = generator.generateApiFileContent(extractor);
        // Ex: "project.api.ts"
        var apiFileName = path.basename(this.buildConfig.rootPath) + '.api.ts';
        this.logVerbose("Output filename is \"" + apiFileName + "\"");
        var actualApiFilePath = path.join(this.buildConfig.tempFolder, apiFileName);
        var foundSourceFiles = 0;
        var self = this;
        var expectedApiFilePath = path.join(this.taskConfig.apiReviewFolder, apiFileName);
        return gulp.src(expectedApiFilePath)
            .pipe(through.obj(function (file, enc, callback) {
            var expectedApiFileContent = file.contents.toString(enc);
            foundSourceFiles++;
            if (!api_extractor_1.ApiFileGenerator.areEquivalentApiFileContents(actualApiFileContent, expectedApiFileContent)) {
                if (self.buildConfig.production) {
                    // For production, issue a warning that will break the CI build.
                    self.logWarning('You have changed the Public API signature for this project.  Please overwrite '
                        + ("'" + expectedApiFilePath.replace(/\\/g, '/') + "' with a copy of '" + actualApiFilePath.replace(/\\/g, '/') + "'")
                        + ' and then request an API review. See the Git repository README.md for more info.');
                }
                else {
                    // For a local build, just copy the file automatically.
                    self.log('You have changed the Public API signature for this project.  Updating '
                        + ("'" + expectedApiFilePath + "'"));
                    fsx.writeFileSync(expectedApiFilePath, actualApiFileContent);
                }
            }
            callback();
        }, function (callback) {
            if (foundSourceFiles === 0) {
                // NOTE: This warning seems like a nuisance, but it has caught genuine mistakes.
                // For example, when projects were moved into category folders, the relative path for
                // the API review files ended up in the wrong place.
                self.logError("This file is missing from the \"apiReviewFolder\": \"" + expectedApiFilePath + "\""
                    + " Please copy it from the project's \"temp\" folder and commit it.");
            }
            else if (foundSourceFiles > 1) {
                self.logError("More than one file matching \"" + expectedApiFilePath + "\" was found. This is not expected.");
            }
            this.push(writeStringToGulpUtilFile(actualApiFileContent, apiFileName));
            callback();
        }))
            .pipe(gulp.dest(this.buildConfig.tempFolder))
            .on('finish', function () { return completeCallback(); });
    };
    ApiExtractorTask.prototype._validateConfiguration = function () {
        if (!this.taskConfig.entry) {
            this.logError('Missing or empty "entry" field in api-extractor.json');
            return false;
        }
        if (!this.taskConfig.apiReviewFolder) {
            this.logError('Missing or empty "apiReviewFolder" field in api-extractor.json');
            return false;
        }
        if (!fsx.existsSync(this.taskConfig.entry)) {
            this.logError("Entry file " + this.taskConfig.entry + " does not exist.");
            return false;
        }
        return true;
    };
    return ApiExtractorTask;
}(gulp_core_build_1.GulpTask));
exports.ApiExtractorTask = ApiExtractorTask;

//# sourceMappingURL=ApiExtractorTask.js.map
