"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("gulp-typescript");
var path = require("path");
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var TypeScriptConfiguration_1 = require("./TypeScriptConfiguration");
/**
 * @public
 */
var TypeScriptTask = (function (_super) {
    __extends(TypeScriptTask, _super);
    function TypeScriptTask() {
        var _this = _super.call(this, 'typescript', {
            failBuildOnErrors: true,
            reporter: {
                error: function (error) {
                    var filename = error.relativeFilename || error.fullFilename || 'unknown filename';
                    var line = error.startPosition ? error.startPosition.line : 0;
                    var character = error.startPosition ? error.startPosition.character : 0;
                    var code = error.diagnostic.code;
                    var errorMessage = (typeof error.diagnostic.messageText === 'object') ?
                        error.diagnostic.messageText.messageText :
                        error.diagnostic.messageText;
                    _this.fileError(filename, line, character, 'TS' + code, errorMessage);
                }
            },
            sourceMatch: [
                'src/**/*.ts',
                'src/**/*.tsx',
                'typings/main/**/*.ts',
                'typings/main.d.ts',
                'typings/tsd.d.ts',
                'typings/index.d.ts'
            ],
            staticMatch: [
                'src/**/*.js',
                'src/**/*.json',
                'src/**/*.jsx'
            ],
            removeCommentsFromJavaScript: false,
            emitSourceMaps: true,
            libDir: undefined,
            libAMDDir: undefined,
            libES6Dir: undefined
        }) || this;
        return _this;
    }
    TypeScriptTask.prototype.loadSchema = function () {
        return require('./schemas/typescript.schema.json');
    };
    TypeScriptTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        /* tslint:disable:typedef */
        var assign = require('object-assign');
        var merge = require('merge2');
        /* tslint:enable:typedef */
        var allStreams = [];
        var result = {
            errorCount: 0
        };
        this._normalizeConfig();
        // Log the compiler version for custom versions.
        var typescript = TypeScriptConfiguration_1.TypeScriptConfiguration.getTypescriptCompiler(); // tslint:disable-line:no-any
        if (typescript && typescript.version) {
            this.log("TypeScript version: " + typescript.version);
        }
        // tslint:disable-next-line:no-any
        var compilerOptions = TypeScriptConfiguration_1.TypeScriptConfiguration.getGulpTypescriptOptions(this.buildConfig).compilerOptions;
        if (compilerOptions.module !== 'commonjs' && compilerOptions.module) {
            this.log("Your tsconfig.json file specifies a different \"target\" than expected. "
                + ("Expected: \"commonjs\". Actual: \"" + compilerOptions.module + "\"."));
        }
        else if (!compilerOptions.module) {
            this.log("Your tsconfig.json file does not specify a \"target\". Using \"commonjs\" instead.");
            compilerOptions.module = 'commonjs';
        }
        this._tsProject = this._tsProject || ts.createProject(compilerOptions);
        this._compileProject(gulp, this._tsProject, this.taskConfig.libDir || this.buildConfig.libFolder, allStreams, result);
        // Static passthrough files.
        var staticSrc = gulp.src(this.taskConfig.staticMatch || []);
        allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libDir || this.buildConfig.libFolder)));
        // If AMD modules are required, also build that.
        if (this.taskConfig.libAMDDir) {
            allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libAMDDir)));
            this._tsAMDProject = this._tsAMDProject || ts.createProject(assign({}, compilerOptions, { module: 'amd' }));
            this._compileProject(gulp, this._tsAMDProject, this.taskConfig.libAMDDir, allStreams, result);
        }
        // If es6 modules are required, also build that.
        if (this.taskConfig.libES6Dir) {
            allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libES6Dir)));
            this._tsES6Project = this._tsES6Project || ts.createProject(assign({}, compilerOptions, { module: 'es6' }));
            this._compileProject(gulp, this._tsES6Project, this.taskConfig.libES6Dir, allStreams, result);
        }
        // Listen for pass/fail, and ensure that the task passes/fails appropriately.
        merge(allStreams)
            .on('queueDrain', function () {
            if (_this.taskConfig.failBuildOnErrors && result.errorCount) {
                completeCallback('TypeScript error(s) occurred.');
            }
            else {
                completeCallback();
            }
        })
            .on('error', completeCallback);
    };
    TypeScriptTask.prototype.getCleanMatch = function (buildConfig, taskConfig) {
        if (taskConfig === void 0) { taskConfig = this.taskConfig; }
        this._normalizeConfig(buildConfig);
        var cleanMatch = [];
        if (this.taskConfig.libDir) {
            cleanMatch.push(this.taskConfig.libDir);
        }
        if (this.taskConfig.libAMDDir) {
            cleanMatch.push(this.taskConfig.libAMDDir);
        }
        if (this.taskConfig.libES6Dir) {
            cleanMatch.push(this.taskConfig.libES6Dir);
        }
        return cleanMatch;
    };
    /** Override the new mergeConfig API */
    TypeScriptTask.prototype.mergeConfig = function (config) {
        throw 'Do not use mergeConfig with gulp-core-build-typescript';
    };
    TypeScriptTask.prototype._normalizeConfig = function (buildConfig) {
        if (buildConfig === void 0) { buildConfig = this.buildConfig; }
        if (!this.taskConfig.libDir) {
            this.taskConfig.libDir = buildConfig.libFolder;
        }
        if (!this.taskConfig.libAMDDir) {
            this.taskConfig.libAMDDir = buildConfig.libAMDFolder;
        }
        if (!this.taskConfig.libES6Dir) {
            this.taskConfig.libES6Dir = buildConfig.libES6Folder;
        }
    };
    TypeScriptTask.prototype._compileProject = function (gulp, tsProject, destDir, allStreams, result) {
        /* tslint:disable:typedef */
        var plumber = require('gulp-plumber');
        var sourcemaps = require('gulp-sourcemaps');
        /* tslint:enable:typedef */
        // tslint:disable-next-line:no-any
        var tsResult = gulp.src(this.taskConfig.sourceMatch || [])
            .pipe(plumber({
            errorHandler: function () {
                result.errorCount++;
            }
        }));
        if (this.taskConfig.emitSourceMaps) {
            tsResult = tsResult.pipe(sourcemaps.init());
        }
        tsResult = tsResult
            .pipe(tsProject(this.taskConfig.reporter));
        // tslint:disable-next-line:typedef
        var jsResult = (this.taskConfig.removeCommentsFromJavaScript
            ? tsResult.js.pipe(require('gulp-decomment')({
                space: !!this.taskConfig.emitSourceMaps /* turn comments into spaces to preserve sourcemaps */
            }))
            : tsResult.js);
        if (this.taskConfig.emitSourceMaps) {
            jsResult = jsResult.pipe(sourcemaps.write('.', { sourceRoot: this._resolveSourceMapRoot }));
        }
        allStreams.push(jsResult
            .pipe(gulp.dest(destDir)));
        allStreams.push(tsResult.dts.pipe(gulp.dest(destDir)));
    };
    TypeScriptTask.prototype._resolveSourceMapRoot = function (file) {
        return path.relative(file.relative, path.join(file.cwd, 'src'));
    };
    return TypeScriptTask;
}(gulp_core_build_1.GulpTask));
exports.TypeScriptTask = TypeScriptTask;

//# sourceMappingURL=TypeScriptTask.js.map
