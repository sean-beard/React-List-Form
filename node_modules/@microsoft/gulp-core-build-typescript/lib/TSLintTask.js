"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
/* tslint:disable:typedef */
var md5 = require('md5');
var merge = require('lodash').merge;
/* tslint:enable:typedef */
var through2 = require("through2");
var gutil = require("gulp-util");
var fs = require("fs");
var TSLint = require("tslint");
var path = require("path");
var TypeScriptConfiguration_1 = require("./TypeScriptConfiguration");
var TSLintTask = (function (_super) {
    __extends(TSLintTask, _super);
    function TSLintTask() {
        var _this = _super.call(this, 'tslint', {
            // lintConfig: require('../lib/defaultTslint.json'),
            lintConfig: {},
            reporter: function (result, file, options) {
                for (var _i = 0, _a = result.failures; _i < _a.length; _i++) {
                    var failure = _a[_i];
                    var pathFromRoot = path.relative(_this.buildConfig.rootPath, file.path);
                    var start = failure.getStartPosition().getLineAndCharacter();
                    if (_this.taskConfig.displayAsWarning) {
                        _this.fileWarning(pathFromRoot, start.line + 1, start.character + 1, failure.getRuleName(), failure.getFailure());
                    }
                    else {
                        _this.fileError(pathFromRoot, start.line + 1, start.character + 1, failure.getRuleName(), failure.getFailure());
                    }
                }
            },
            rulesDirectory: (function () {
                var msCustomRulesMain = require.resolve('tslint-microsoft-contrib');
                var msCustomRulesDirectory = path.dirname(msCustomRulesMain);
                return TSLint.Configuration.getRulesDirectories([msCustomRulesDirectory], __dirname);
            })(),
            sourceMatch: [
                'src/**/*.ts',
                'src/**/*.tsx'
            ],
            removeExistingRules: false,
            useDefaultConfigAsBase: true
        }) || this;
        _this._defaultLintRules = undefined; // tslint:disable-line:no-any
        return _this;
    }
    TSLintTask.prototype.mergeConfig = function (config) {
        this._prepareUpdateConfig(config);
        _super.prototype.mergeConfig.call(this, config);
    };
    TSLintTask.prototype.setConfig = function (config) {
        this._prepareUpdateConfig(config);
        _super.prototype.setConfig.call(this, config);
    };
    TSLintTask.prototype.loadSchema = function () {
        return require('./schemas/tslint.schema.json');
    };
    TSLintTask.prototype.executeTask = function (gulp, completeCallback) {
        var self = this;
        if (!this.taskConfig.sourceMatch) {
            completeCallback('taskConfig.sourceMatch must be defined');
            return;
        }
        if (!this.taskConfig.reporter) {
            completeCallback('taskConfig.reporter must be defined');
            return;
        }
        var lintRulesFile = self._loadLintConfiguration();
        // Write out the active lint rules for easier debugging
        if (!fs.existsSync(path.dirname(this._getTsLintFilepath()))) {
            fs.mkdirSync(path.dirname(this._getTsLintFilepath()));
        }
        fs.writeFileSync(this._getTsLintFilepath(), JSON.stringify(lintRulesFile, undefined, 2));
        var cached = require('gulp-cache'); // tslint:disable-line
        var program = undefined;
        try {
            var tsconfigFileData = TypeScriptConfiguration_1.TypeScriptConfiguration.getTsConfigFile(this.buildConfig);
            var tsconfigFilePath = path.join(this.buildConfig.rootPath, this.buildConfig.tempFolder, 'tslint-tsconfig.json');
            fs.writeFileSync(tsconfigFilePath, JSON.stringify(tsconfigFileData, undefined, 2));
            program = TSLint.Linter.createProgram(tsconfigFilePath, path.join(this.buildConfig.rootPath, this.buildConfig.srcFolder));
        }
        catch (e) {
            this.logWarning("Unable to create a TS program for TSLint. Some lint rules might not work correctly. Error " + e);
        }
        return gulp.src(this.taskConfig.sourceMatch)
            .pipe(cached(through2.obj(function (file, encoding, callback) {
            self.logVerbose(file.path);
            // Lint the file
            if (file.isNull()) {
                return callback(undefined, file);
            }
            // Stream is not supported
            if (file.isStream()) {
                this.emit('error', new gutil.PluginError(this.name, 'Streaming not supported'));
                return callback();
            }
            var options = {
                fix: false,
                formatter: 'json',
                formattersDirectory: undefined,
                rulesDirectory: self.taskConfig.rulesDirectory || []
            };
            var linter = new TSLint.Linter(options, program);
            var configuration = TSLint.Configuration.parseConfigFile(lintRulesFile);
            linter.lint(file.path, file.contents.toString(), configuration);
            var result = linter.getResult();
            /* tslint:disable:no-string-literal */
            file['tslint'] = result;
            /* tslint:enable:no-string-literal */
            // We can't get here if reporter is undefined
            if (result.errorCount > 0 && self.taskConfig.reporter) {
                self.taskConfig.reporter(result, file, self.taskConfig);
            }
            this.push(file);
            callback();
        }), {
            // Scope the cache to a combination of the lint rules and the build path
            name: md5(TSLint.Linter.VERSION + JSON.stringify(lintRulesFile) +
                self.name + self.buildConfig.rootPath),
            // What on the result indicates it was successful
            success: function (jshintedFile) {
                /* tslint:disable:no-string-literal */
                return jshintedFile['tslint'].failureCount === 0;
                /* tslint:enable:no-string-literal */
            },
            // By default, the cache attempts to store the value of the objects in the stream
            // For this task, this is over-engineering since we never need to store anything extra.
            value: function (file) {
                return {
                    path: file.path
                };
            }
        }));
    };
    TSLintTask.prototype.getCleanMatch = function (buildConfig, taskConfig) {
        if (taskConfig === void 0) { taskConfig = this.taskConfig; }
        return [path.join(buildConfig.rootPath, buildConfig.tempFolder)];
    };
    TSLintTask.prototype._prepareUpdateConfig = function (newConfig) {
        // If the removeExistingRules flag is set, clear out any existing rules
        if (newConfig.removeExistingRules &&
            this.taskConfig &&
            this.taskConfig.lintConfig) {
            delete this.taskConfig.lintConfig.rules;
            delete newConfig.removeExistingRules;
        }
    };
    TSLintTask.prototype._getTsLintFilepath = function () {
        return path.join(this.buildConfig.rootPath, this.buildConfig.tempFolder, 'tslint.json');
    };
    TSLintTask.prototype._loadLintConfiguration = function () {
        if (!this._defaultLintRules) {
            this._defaultLintRules = require('./defaultTslint.json');
        }
        return merge((this.taskConfig.useDefaultConfigAsBase ? this._defaultLintRules : {}), this.taskConfig.lintConfig || {});
    };
    return TSLintTask;
}(gulp_core_build_1.GulpTask));
exports.TSLintTask = TSLintTask;

//# sourceMappingURL=TSLintTask.js.map
