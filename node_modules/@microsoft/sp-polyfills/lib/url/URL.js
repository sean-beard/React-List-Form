"use strict";
/**
 * This is an incomplete implementation of a URL polyfill. These things are not supported, or not fully supported:
 *  - baseURLString constructor property
 *      This means that `new URL('http://contoso.com/path/to/something', 'http://fabrikam.com')` will not work,
 *        but the same thing can be accomplished with:
 *      const url = new new URL('http://contoso.com/path/to/something');
 *      url.host = 'fabrikam.com';
 *
 *  - Username
 *      The username property is not supported and will always return the empty string. Setting the username has
 *        no effect.
 *
 *  - Password
 *      The password property is not supported and will always return the empty string. Setting the password has
 *        no effect.
 *
 *  - Setting the pathname property with a value containing encoded values will double-encode the encoded values.
 *      For example. myUrl.pathname = "path%2Bto/resource.json" => myUrl.pathname === "/path%252Bto/resource.json"
 *      To set the pathname to a value that contains a special character, set it with the un-encoded character.
 *      The encoded "/" character (%2F) is not supported
 *
 * MDN documentation: https://developer.mozilla.org/en-US/docs/Web/API/URL
 *
 * WhatWG Spec: https://url.spec.whatwg.org/
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BaseURL_1 = require("./BaseURL");
var SPECIAL_SCHEMES_AND_PORTS = {
    'ftp:': '21',
    'gopher:': '70',
    'http:': '80',
    'https:': '443',
    'ws:': '80',
    'wss:': '443'
};
/**
 * Ensures the URL has a scheme
 */
function urlIsValid(url) {
    return !!url.match(/^.+\:/);
}
var URL = (function (_super) {
    __extends(URL, _super);
    function URL(url, baseURLString) {
        var _this = this;
        if (!urlIsValid(url)) {
            throw new TypeError('Invalid URL');
        }
        _this = _super.call(this, url, baseURLString) || this;
        _this._shadowDocument = document.implementation.createHTMLDocument('');
        _this._innerAnchorElement = _this._shadowDocument.createElement('a');
        if (baseURLString) {
            throw new Error('baseURLString parameter is not supported by the URL polyfill.');
        }
        _this._innerAnchorElement.href = url;
        _this._initializeSearchParams();
        return _this;
    }
    Object.defineProperty(URL.prototype, "href", {
        get: function () {
            var result = this._innerAnchorElement.href;
            if (this._hashHashBeenCleared) {
                if (result.match(/\#$/)) {
                    result = result.substr(0, result.length - 1);
                }
                if (this._searchHasBeenCleared && result.match(/\?$/)) {
                    result = result.substr(0, result.length - 1);
                }
            }
            else if (this._searchHasBeenCleared) {
                var firstIndexOfHash = result.indexOf('#');
                if (firstIndexOfHash === -1) {
                    // No fragment
                    if (result.match(/\?$/)) {
                        result = result.substr(0, result.length - 1);
                    }
                }
                else if (result.charAt(firstIndexOfHash - 1) === '?') {
                    result = result.substring(0, firstIndexOfHash - 1) + result.substr(firstIndexOfHash);
                }
            }
            return result;
        },
        set: function (newValue) {
            if (!urlIsValid(newValue)) {
                throw new TypeError('Invalid URL');
            }
            this._invalidate();
            this._innerAnchorElement.href = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "origin", {
        get: function () {
            if (SPECIAL_SCHEMES_AND_PORTS.hasOwnProperty(this.protocol)) {
                if (!this.port || SPECIAL_SCHEMES_AND_PORTS[this.protocol] === this.port) {
                    // Standard port, don't serialize the port
                    return this.protocol + "//" + this._innerAnchorElement.hostname;
                }
                else {
                    // Non-standard port, serialize the port
                    return this.protocol + "//" + this._innerAnchorElement.hostname + ":" + this.port;
                }
            }
            else {
                return 'null';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "protocol", {
        get: function () {
            return this._innerAnchorElement.protocol;
        },
        set: function (newValue) {
            // Trim the trailing ":" and serialize "null" or "undefined" as a weird caveat of the spec
            var protocolMatches = ("" + newValue).match(/^([^\:]+):?$/);
            if (protocolMatches) {
                this._invalidate();
                this._innerAnchorElement.protocol = protocolMatches[1] + ":";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "username", {
        get: function () {
            return ''; // Not supported
        },
        set: function (newValue) {
            // Not supported
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "password", {
        get: function () {
            return ''; // Not supported
        },
        set: function (newValue) {
            // Not supported
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "host", {
        get: function () {
            return this._innerAnchorElement.host;
        },
        set: function (newValue) {
            this._invalidate();
            this._innerAnchorElement.host = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "hostname", {
        get: function () {
            return this._innerAnchorElement.hostname;
        },
        set: function (newValue) {
            this._invalidate();
            this._innerAnchorElement.hostname = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "port", {
        get: function () {
            return this._innerAnchorElement.port;
        },
        set: function (newValue) {
            this._invalidate();
            if (newValue) {
                this._innerAnchorElement.port = newValue;
            }
            else {
                this._innerAnchorElement.port = SPECIAL_SCHEMES_AND_PORTS[this.protocol] || newValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "pathname", {
        get: function () {
            return this._innerAnchorElement.pathname;
        },
        set: function (newValue) {
            this._invalidate();
            this._innerAnchorElement.pathname = newValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "hash", {
        get: function () {
            return this._innerAnchorElement.hash;
        },
        set: function (newValue) {
            this._invalidate();
            this._innerAnchorElement.hash = '';
            // Trim the leading "#" and serialize "null" or "undefined" as a weird caveat of the spec
            var fragmentMatches = ("" + newValue).match(/^#?(.*)/);
            if (fragmentMatches && !!fragmentMatches[1]) {
                this._innerAnchorElement.hash = fragmentMatches[1];
                this._hashHashBeenCleared = false;
            }
            else {
                this._hashHashBeenCleared = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URL.prototype, "_query", {
        get: function () {
            return this._innerAnchorElement.search;
        },
        set: function (newValue) {
            this._innerAnchorElement.search = '';
            if (!!newValue) {
                this._innerAnchorElement.search = newValue;
                this._searchHasBeenCleared = false;
            }
            else {
                this._searchHasBeenCleared = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    URL.prototype._invalidate = function () { };
    return URL;
}(BaseURL_1.default));
exports.default = URL;

//# sourceMappingURL=URL.js.map
