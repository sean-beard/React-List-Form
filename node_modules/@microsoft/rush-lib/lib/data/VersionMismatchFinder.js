// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @public
 */
var VersionMismatchFinder = (function () {
    function VersionMismatchFinder(_projects) {
        this._projects = _projects;
        this._mismatches = new Map();
        this._analyze();
    }
    Object.defineProperty(VersionMismatchFinder.prototype, "numberOfMismatches", {
        get: function () {
            return this._mismatches.size;
        },
        enumerable: true,
        configurable: true
    });
    VersionMismatchFinder.prototype.getMismatches = function () {
        return this._iterableToArray(this._mismatches.keys());
    };
    VersionMismatchFinder.prototype.getVersionsOfMismatch = function (mismatch) {
        return this._mismatches.has(mismatch)
            ? this._iterableToArray(this._mismatches.get(mismatch).keys())
            : undefined;
    };
    VersionMismatchFinder.prototype.getConsumersOfMismatch = function (mismatch, version) {
        var mismatchedPackage = this._mismatches.get(mismatch);
        if (!mismatchedPackage) {
            return undefined;
        }
        var mismatchedVersion = mismatchedPackage.get(version);
        return mismatchedVersion;
    };
    VersionMismatchFinder.prototype._analyze = function () {
        var _this = this;
        this._projects.forEach(function (project) {
            _this._addDependenciesToList(project.packageName, project.packageJson.dependencies, project.cyclicDependencyProjects);
            _this._addDependenciesToList(project.packageName, project.packageJson.devDependencies, project.cyclicDependencyProjects);
            _this._addDependenciesToList(project.packageName, project.packageJson.peerDependencies, project.cyclicDependencyProjects);
            _this._addDependenciesToList(project.packageName, project.packageJson.optionalDependencies, project.cyclicDependencyProjects);
        });
        this._mismatches.forEach(function (mismatches, project) {
            if (mismatches.size <= 1) {
                _this._mismatches.delete(project);
            }
        });
    };
    VersionMismatchFinder.prototype._addDependenciesToList = function (project, dependencyMap, exclude) {
        var _this = this;
        Object.keys(dependencyMap || {}).forEach(function (dependency) {
            if (!exclude || !exclude.has(dependency)) {
                var version = dependencyMap[dependency];
                if (!_this._mismatches.has(dependency)) {
                    _this._mismatches.set(dependency, new Map());
                }
                if (!_this._mismatches.get(dependency).has(version)) {
                    _this._mismatches.get(dependency).set(version, []);
                }
                _this._mismatches.get(dependency).get(version).push(project);
            }
        });
    };
    VersionMismatchFinder.prototype._iterableToArray = function (iterable) {
        var b = [];
        var a;
        while ((a = iterable.next()) && !a.done) {
            b.push(a.value);
        }
        return b;
    };
    return VersionMismatchFinder;
}());
exports.VersionMismatchFinder = VersionMismatchFinder;

//# sourceMappingURL=VersionMismatchFinder.js.map
