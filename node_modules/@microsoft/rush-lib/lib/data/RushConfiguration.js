// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var fsx = require("fs-extra");
var os = require("os");
var semver = require("semver");
var rushVersion_1 = require("../rushVersion");
var JsonFile_1 = require("../utilities/JsonFile");
var RushConfigurationProject_1 = require("./RushConfigurationProject");
var PinnedVersionsConfiguration_1 = require("./PinnedVersionsConfiguration");
var Utilities_1 = require("../utilities/Utilities");
var RushConstants_1 = require("../RushConstants");
var ApprovedPackagesPolicy_1 = require("./ApprovedPackagesPolicy");
var JsonSchemaValidator_1 = require("../utilities/JsonSchemaValidator");
var EventHooks_1 = require("./EventHooks");
var VersionPolicyConfiguration_1 = require("./VersionPolicyConfiguration");
/**
 * A list of known config filenames that are expected to appear in the "./common/config/rush" folder.
 * To avoid confusion/mistakes, any extra files will be reported as an error.
 */
var knownRushConfigFilenames = [
    '.npmrc',
    RushConstants_1.RushConstants.npmShrinkwrapFilename,
    RushConstants_1.RushConstants.pinnedVersionsFilename,
    RushConstants_1.RushConstants.browserApprovedPackagesFilename,
    RushConstants_1.RushConstants.nonbrowserApprovedPackagesFilename,
    RushConstants_1.RushConstants.versionPoliciesFileName
];
/**
 * This represents the Rush configuration for a repository, based on the Rush.json
 * configuration file.
 * @public
 */
var RushConfiguration = (function () {
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    function RushConfiguration(rushConfigurationJson, rushJsonFilename) {
        var _this = this;
        if (rushConfigurationJson.nodeSupportedVersionRange) {
            if (!semver.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error('Error parsing the node-semver expression in the "nodeSupportedVersionRange"'
                    + (" field from rush.json: \"" + rushConfigurationJson.nodeSupportedVersionRange + "\""));
            }
            if (!semver.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error("Your dev environment is running Node.js version " + process.version + " which does"
                    + " not meet the requirements for building this repository.  (The rush.json configuration"
                    + (" requires nodeSupportedVersionRange=\"" + rushConfigurationJson.nodeSupportedVersionRange + "\")"));
            }
        }
        this._rushJsonFolder = path.dirname(rushJsonFilename);
        this._commonFolder = path.resolve(path.join(this._rushJsonFolder, RushConstants_1.RushConstants.commonFolderName));
        this._commonRushConfigFolder = path.join(this._commonFolder, 'config', 'rush');
        RushConfiguration._validateCommonRushConfigFolder(this._commonRushConfigFolder);
        this._commonTempFolder = path.join(this._commonFolder, RushConstants_1.RushConstants.rushTempFolderName);
        this._npmCacheFolder = path.resolve(path.join(this._commonTempFolder, 'npm-cache'));
        this._npmTmpFolder = path.resolve(path.join(this._commonTempFolder, 'npm-tmp'));
        this._committedShrinkwrapFilename = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.npmShrinkwrapFilename);
        this._tempShrinkwrapFilename = path.join(this._commonTempFolder, RushConstants_1.RushConstants.npmShrinkwrapFilename);
        var unresolvedUserFolder = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];
        this._homeFolder = path.resolve(unresolvedUserFolder);
        if (!fsx.existsSync(this._homeFolder)) {
            throw new Error('Unable to determine the current user\'s home directory');
        }
        this._rushLinkJsonFilename = path.join(this._commonTempFolder, 'rush-link.json');
        this._npmToolVersion = rushConfigurationJson.npmVersion;
        this._npmToolFilename = path.resolve(path.join(this._commonTempFolder, 'npm-local', 'node_modules', '.bin', 'npm'));
        this._projectFolderMinDepth = rushConfigurationJson.projectFolderMinDepth !== undefined
            ? rushConfigurationJson.projectFolderMinDepth : 1;
        if (this._projectFolderMinDepth < 1) {
            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');
        }
        this._projectFolderMaxDepth = rushConfigurationJson.projectFolderMaxDepth !== undefined
            ? rushConfigurationJson.projectFolderMaxDepth : 2;
        if (this._projectFolderMaxDepth < this._projectFolderMinDepth) {
            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');
        }
        this._approvedPackagesPolicy = new ApprovedPackagesPolicy_1.ApprovedPackagesPolicy(this, rushConfigurationJson);
        this._gitAllowedEmailRegExps = [];
        this._gitSampleEmail = '';
        if (rushConfigurationJson.gitPolicy) {
            if (rushConfigurationJson.gitPolicy.sampleEmail) {
                this._gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;
            }
            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {
                this._gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;
                if (this._gitSampleEmail.trim().length < 1) {
                    throw new Error('The rush.json file is missing the "sampleEmail" option, ' +
                        'which is required when using "allowedEmailRegExps"');
                }
            }
        }
        this._telemetryEnabled = !!rushConfigurationJson.telemetryEnabled;
        if (rushConfigurationJson.eventHooks) {
            this._eventHooks = new EventHooks_1.default(rushConfigurationJson.eventHooks);
        }
        var versionPolicyConfigFile = path.join(this._commonRushConfigFolder, RushConstants_1.RushConstants.versionPoliciesFileName);
        this._versionPolicyConfiguration = new VersionPolicyConfiguration_1.VersionPolicyConfiguration(versionPolicyConfigFile);
        this._projects = [];
        this._projectsByName = new Map();
        // We sort the projects array in alphabetical order.  This ensures that the packages
        // are processed in a deterministic order by the various Rush algorithms.
        var sortedProjectJsons = rushConfigurationJson.projects.slice(0);
        sortedProjectJsons.sort(function (a, b) { return a.packageName.localeCompare(b.packageName); });
        var tempNamesByProject = RushConfiguration._generateTempNamesForProjects(sortedProjectJsons);
        for (var _i = 0, sortedProjectJsons_1 = sortedProjectJsons; _i < sortedProjectJsons_1.length; _i++) {
            var projectJson = sortedProjectJsons_1[_i];
            var tempProjectName = tempNamesByProject.get(projectJson);
            var project = new RushConfigurationProject_1.default(projectJson, this, tempProjectName);
            this._projects.push(project);
            if (this._projectsByName.get(project.packageName)) {
                throw new Error("The project name \"" + project.packageName + "\" was specified more than once"
                    + " in the rush.json configuration file.");
            }
            this._projectsByName.set(project.packageName, project);
        }
        var _loop_1 = function (project) {
            project.cyclicDependencyProjects.forEach(function (cyclicDependencyProject) {
                if (!_this.getProjectByName(cyclicDependencyProject)) {
                    throw new Error("In rush.json, the \"" + cyclicDependencyProject + "\" project does not exist,"
                        + (" but was referenced by the cyclicDependencyProjects for " + project.packageName));
                }
            });
            // Compute the downstream dependencies within the list of Rush projects.
            this_1._populateDownstreamDependencies(project.packageJson.dependencies, project.packageName);
            this_1._populateDownstreamDependencies(project.packageJson.devDependencies, project.packageName);
        };
        var this_1 = this;
        for (var _a = 0, _b = this._projects; _a < _b.length; _a++) {
            var project = _b[_a];
            _loop_1(project);
        }
        // Example: "./common/config/rush/pinnedVersions.json"
        var pinnedVersionsFile = path.join(this.commonRushConfigFolder, RushConstants_1.RushConstants.pinnedVersionsFilename);
        this._pinnedVersions = PinnedVersionsConfiguration_1.PinnedVersionsConfiguration.tryLoadFromFile(pinnedVersionsFile);
    }
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    RushConfiguration.loadFromConfigurationFile = function (rushJsonFilename) {
        var rushConfigurationJson = JsonFile_1.default.loadJsonFile(rushJsonFilename);
        // Check the Rush version *before* we validate the schema, since if the version is outdated
        // then the schema may have changed.
        var rushMinimumVersion = rushConfigurationJson.rushMinimumVersion;
        // If the version is missing or malformed, fall through and let the schema handle it.
        if (rushMinimumVersion && semver.valid(rushMinimumVersion)) {
            if (semver.lt(rushVersion_1.default, rushMinimumVersion)) {
                throw new Error("Your rush tool is version " + rushVersion_1.default + ", but rush.json"
                    + (" requires version " + rushConfigurationJson.rushMinimumVersion + " or newer.  To upgrade,")
                    + " run \"npm install @microsoft/rush -g\".");
            }
        }
        var rushSchemaFilename = path.join(__dirname, '../rush.schema.json');
        var validator = JsonSchemaValidator_1.default.loadFromFile(rushSchemaFilename);
        validator.validateObject(rushConfigurationJson, function (errorDescription) {
            var errorMessage = "Error parsing file '" + rushJsonFilename + "':"
                + os.EOL + errorDescription;
            throw new Error(errorMessage);
        });
        return new RushConfiguration(rushConfigurationJson, rushJsonFilename);
    };
    RushConfiguration.loadFromDefaultLocation = function () {
        var currentFolder = process.cwd();
        // Look upwards at parent folders until we find a folder containing rush.json
        for (var i = 0; i < 10; ++i) {
            var rushJsonFilename = path.join(currentFolder, 'rush.json');
            if (fsx.existsSync(rushJsonFilename)) {
                if (i > 0) {
                    console.log('Found configuration in ' + rushJsonFilename);
                }
                console.log('');
                return RushConfiguration.loadFromConfigurationFile(rushJsonFilename);
            }
            var parentFolder = path.dirname(currentFolder);
            if (parentFolder === currentFolder) {
                break;
            }
            currentFolder = parentFolder;
        }
        throw new Error('Unable to find rush.json configuration file');
    };
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    RushConfiguration._generateTempNamesForProjects = function (sortedProjectJsons) {
        var tempNamesByProject = new Map();
        var usedTempNames = new Set();
        // NOTE: projectJsons was already sorted in alphabetical order by the caller.
        for (var _i = 0, sortedProjectJsons_2 = sortedProjectJsons; _i < sortedProjectJsons_2.length; _i++) {
            var projectJson = sortedProjectJsons_2[_i];
            // If the name is "@ms/MyProject", extract the "MyProject" part
            var unscopedName = Utilities_1.default.parseScopedPackageName(projectJson.packageName).name;
            // Generate a unique like name "@rush-temp/MyProject", or "@rush-temp/MyProject-2" if
            // there is a naming conflict
            var counter = 0;
            var tempProjectName = RushConstants_1.RushConstants.rushTempNpmScope + "/" + unscopedName;
            while (usedTempNames.has(tempProjectName)) {
                ++counter;
                tempProjectName = RushConstants_1.RushConstants.rushTempNpmScope + "/" + unscopedName + "-" + counter;
            }
            usedTempNames.add(tempProjectName);
            tempNamesByProject.set(projectJson, tempProjectName);
        }
        return tempNamesByProject;
    };
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    RushConfiguration._validateCommonRushConfigFolder = function (commonRushConfigFolder) {
        if (!fsx.existsSync(commonRushConfigFolder)) {
            console.log("Creating folder: " + commonRushConfigFolder);
            fsx.mkdirsSync(commonRushConfigFolder);
            return;
        }
        var filenames = fsx.readdirSync(commonRushConfigFolder);
        for (var _i = 0, filenames_1 = filenames; _i < filenames_1.length; _i++) {
            var filename = filenames_1[_i];
            var resolvedFilename = path.resolve(commonRushConfigFolder, filename);
            // Ignore things that aren't actual files
            var stat = fsx.lstatSync(resolvedFilename);
            if (!stat.isFile() && !stat.isSymbolicLink()) {
                continue;
            }
            // Ignore harmless file extensions
            var fileExtension = path.extname(filename);
            if (['.bak', '.disabled', '.md', '.old', '.orig'].indexOf(fileExtension) >= 0) {
                continue;
            }
            var knownSet = new Set(knownRushConfigFilenames.map(function (x) { return x.toUpperCase(); }));
            // Is the filename something we know?  If not, report an error.
            if (!knownSet.has(filename.toUpperCase())) {
                throw new Error("An unrecognized file \"" + filename + "\" was found in the Rush config folder:"
                    + (" " + commonRushConfigFolder));
            }
        }
    };
    Object.defineProperty(RushConfiguration.prototype, "rushJsonFolder", {
        /**
         * The folder that contains rush.json for this project.
         */
        get: function () {
            return this._rushJsonFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "commonFolder", {
        /**
         * The fully resolved path for the "common" folder where Rush will store settings that
         * affect all Rush projects.  This is always a subfolder of the folder containing "rush.json".
         * Example: "C:\MyRepo\common"
         */
        get: function () {
            return this._commonFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "commonRushConfigFolder", {
        /**
         * The folder where Rush's additional config files are stored.  This folder is always a
         * subfolder called "config\rush" inside the common folder.  (The "common\config" folder
         * is reserved for configuration files used by other tools.)  To avoid confusion or mistakes,
         * Rush will report an error if this this folder contains any unrecognized files.
         *
         * Example: "C:\MyRepo\common\config\rush"
         */
        get: function () {
            return this._commonRushConfigFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "commonTempFolder", {
        /**
         * The folder where temporary files will be stored.  This is always a subfolder called "temp"
         * inside the common folder.
         * Example: "C:\MyRepo\common\temp"
         */
        get: function () {
            return this._commonTempFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "npmCacheFolder", {
        /**
         * The local folder that will store the NPM package cache.  Rush does not rely on the
         * NPM's default global cache folder, because NPM's caching implementation does not
         * reliably handle multiple processes.  (For example, if a build box is running
         * "rush install" simultaneously for two different working folders, it may fail randomly.)
         *
         * Example: "C:\MyRepo\common\temp\npm-cache"
         */
        get: function () {
            return this._npmCacheFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "npmTmpFolder", {
        /**
         * The local folder where NPM's temporary files will be written during installation.
         * Rush does not rely on the global default folder, because it may be on a different
         * hard disk.
         *
         * Example: "C:\MyRepo\common\temp\npm-tmp"
         */
        get: function () {
            return this._npmTmpFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "committedShrinkwrapFilename", {
        /**
         * The filename of the NPM shrinkwrap file that is tracked e.g. by Git.  (The "rush install"
         * command uses a temporary copy, whose path is tempShrinkwrapFilename.)
         * This property merely reports the filename; the file itself may not actually exist.
         * Example: "C:\MyRepo\common\npm-shrinkwrap.json"
         */
        get: function () {
            return this._committedShrinkwrapFilename;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "tempShrinkwrapFilename", {
        /**
         * The filename of the temporary NPM shrinkwrap file that is used by "rush install".
         * (The master copy is tempShrinkwrapFilename.)
         * This property merely reports the filename; the file itself may not actually exist.
         * Example: "C:\MyRepo\common\temp\npm-shrinkwrap.json"
         */
        get: function () {
            return this._tempShrinkwrapFilename;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "homeFolder", {
        /**
         * The absolute path to the home directory for the current user.  On Windows,
         * it would be something like "C:\Users\YourName".
         */
        get: function () {
            return this._homeFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "rushLinkJsonFilename", {
        /**
         * The filename of the build dependency data file.  By default this is
         * called 'rush-link.json' resides in the Rush common folder.
         * Its data structure is defined by IRushLinkJson.
         *
         * Example: "C:\MyRepo\common\temp\rush-link.json"
         */
        get: function () {
            return this._rushLinkJsonFilename;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "npmToolVersion", {
        /**
         * The version of the locally installed NPM tool.  (Example: "1.2.3")
         */
        get: function () {
            return this._npmToolVersion;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "npmToolFilename", {
        /**
         * The absolute path to the locally installed NPM tool.  If "rush install" has not
         * been run, then this file may not exist yet.
         * Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
         */
        get: function () {
            return this._npmToolFilename;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "projectFolderMinDepth", {
        /**
         * The minimum allowable folder depth for the projectFolder field in the rush.json file.
         * This setting provides a way for repository maintainers to discourage nesting of project folders
         * that makes the directory tree more difficult to navigate.  The default value is 2,
         * which implements a standard 2-level hierarchy of <categoryFolder>/<projectFolder>/package.json.
         */
        get: function () {
            return this._projectFolderMinDepth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "projectFolderMaxDepth", {
        /**
         * The maximum allowable folder depth for the projectFolder field in the rush.json file.
         * This setting provides a way for repository maintainers to discourage nesting of project folders
         * that makes the directory tree more difficult to navigate.  The default value is 2,
         * which implements on a standard convention of <categoryFolder>/<projectFolder>/package.json.
         */
        get: function () {
            return this._projectFolderMaxDepth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "approvedPackagesPolicy", {
        /**
         * The "approvedPackagesPolicy" settings.
         */
        get: function () {
            return this._approvedPackagesPolicy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "gitAllowedEmailRegExps", {
        /**
         * [Part of the "gitPolicy" feature.]
         * A list of regular expressions describing allowable e-mail patterns for Git commits.
         * They are case-insensitive anchored JavaScript RegExps.
         * Example: ".*@example\.com"
         * This array will never be undefined.
         */
        get: function () {
            return this._gitAllowedEmailRegExps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "gitSampleEmail", {
        /**
         * [Part of the "gitPolicy" feature.]
         * An example valid e-mail address that conforms to one of the allowedEmailRegExps.
         * Example: "foxtrot@example\.com"
         * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
         */
        get: function () {
            return this._gitSampleEmail;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "telemetryEnabled", {
        /**
         * Indicates whether telemetry collection is enabled for Rush runs.
         * @alpha
         */
        get: function () {
            return this._telemetryEnabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "projects", {
        get: function () {
            return this._projects;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "projectsByName", {
        get: function () {
            return this._projectsByName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "pinnedVersions", {
        /**
         * The PinnedVersionsConfiguration object.  If the pinnedVersions.json file is missing,
         * this property will NOT be undefined.  Instead it will be initialized in an empty state,
         * and calling PinnedVersionsConfiguration.save() will create the file.
         */
        get: function () {
            return this._pinnedVersions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "eventHooks", {
        /**
         * The rush hooks. It allows cusomized scripts to run at the specified point.
         * @alpha
         */
        get: function () {
            return this._eventHooks;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    RushConfiguration.prototype.getProjectByName = function (projectName) {
        return this._projectsByName.get(projectName);
    };
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like "@something/example".  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    RushConfiguration.prototype.findProjectByShorthandName = function (shorthandProjectName) {
        // Is there an exact match?
        var result = this._projectsByName.get(shorthandProjectName);
        if (result) {
            return result;
        }
        // Is there an approximate match?
        for (var _i = 0, _a = this._projects; _i < _a.length; _i++) {
            var project = _a[_i];
            if (Utilities_1.default.parseScopedPackageName(project.packageName).name === shorthandProjectName) {
                if (result) {
                    // Ambiguous -- there is more than one match
                    return undefined;
                }
                else {
                    result = project;
                }
            }
        }
        return result;
    };
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    RushConfiguration.prototype.findProjectByTempName = function (tempProjectName) {
        // Is there an approximate match?
        for (var _i = 0, _a = this._projects; _i < _a.length; _i++) {
            var project = _a[_i];
            if (project.tempProjectName === tempProjectName) {
                return project;
            }
        }
        return undefined;
    };
    Object.defineProperty(RushConfiguration.prototype, "versionPolicyConfiguration", {
        /**
         * @alpha
         */
        get: function () {
            return this._versionPolicyConfiguration;
        },
        enumerable: true,
        configurable: true
    });
    RushConfiguration.prototype._populateDownstreamDependencies = function (dependencies, packageName) {
        var _this = this;
        if (!dependencies) {
            return;
        }
        Object.keys(dependencies).forEach(function (dependencyName) {
            var depProject = _this._projectsByName.get(dependencyName);
            if (depProject) {
                depProject.downstreamDependencyProjects.push(packageName);
            }
        });
    };
    return RushConfiguration;
}());
exports.default = RushConfiguration;

//# sourceMappingURL=RushConfiguration.js.map
