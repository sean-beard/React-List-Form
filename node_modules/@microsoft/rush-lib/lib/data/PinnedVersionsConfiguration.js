// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var semver = require("semver");
var JsonFile_1 = require("../utilities/JsonFile");
/**
 * Pinned Versions is a Rush feature designed to mimic the behavior of NPM
 * when performing an install. Essentially, for a project, NPM installs all of
 * the first level dependencies before starting any second-level dependencies.
 * This means that you can control the specific version of a second-level dependency
 * by promoting it to a 1st level dependency and using a version number that would satisfy.
 * However, since rush uses the /common/package.json file, NPM treats each rush project
 * as a top-level dependency, and treats the actual 1st level dependencies as second order.
 * This means you could have cases where there is unnecessary inversion and side-by-side versioning
 * in your shrinkwrap file. To mitigate this issue, we promote some dependencies and list them
 * directly in the /common/package.json, ensuring that the selected version will be installed first
 * and at the root.
 * @public
 */
var PinnedVersionsConfiguration = (function () {
    /**
     * Preferred to use PinnedVersionsConfiguration.loadFromFile()
     */
    function PinnedVersionsConfiguration(pinnedVersionJson, _filename) {
        var _this = this;
        this._filename = _filename;
        this._data = new Map();
        Object.keys(pinnedVersionJson || {}).forEach(function (dep) {
            _this.set(dep, pinnedVersionJson[dep]);
        });
    }
    /** Attempts to load pinned versions configuration from a given file */
    PinnedVersionsConfiguration.tryLoadFromFile = function (jsonFilename) {
        var pinnedVersionJson = undefined;
        if (fs.existsSync(jsonFilename)) {
            pinnedVersionJson = JsonFile_1.default.loadJsonFile(jsonFilename);
        }
        return new PinnedVersionsConfiguration(pinnedVersionJson, jsonFilename);
    };
    /** Set a pinned version. Checks that the version is a valid semver. */
    PinnedVersionsConfiguration.prototype.set = function (dependency, version) {
        if (!semver.valid(version) && !semver.validRange(version)) {
            throw new Error("The pinned version \"" + version + "\" for \"" + dependency + "\" project is not a valid semantic version.");
        }
        this._data.set(dependency, version);
        return this;
    };
    PinnedVersionsConfiguration.prototype.get = function (dependency) {
        return this._data.get(dependency);
    };
    PinnedVersionsConfiguration.prototype.has = function (dependency) {
        return this._data.has(dependency);
    };
    PinnedVersionsConfiguration.prototype.forEach = function (cb) {
        this._data.forEach(cb);
        return this;
    };
    PinnedVersionsConfiguration.prototype.save = function () {
        JsonFile_1.default.saveJsonFile(this._serialize(), this._filename);
        return this;
    };
    PinnedVersionsConfiguration.prototype.delete = function (dependency) {
        return this._data.delete(dependency);
    };
    PinnedVersionsConfiguration.prototype.clear = function () {
        this._data.clear();
        return this;
    };
    Object.defineProperty(PinnedVersionsConfiguration.prototype, "size", {
        get: function () {
            return this._data.size;
        },
        enumerable: true,
        configurable: true
    });
    PinnedVersionsConfiguration.prototype._serialize = function () {
        var rawJson = {};
        this._data.forEach(function (version, dependency) {
            rawJson[dependency] = version;
        });
        return rawJson;
    };
    return PinnedVersionsConfiguration;
}());
exports.PinnedVersionsConfiguration = PinnedVersionsConfiguration;

//# sourceMappingURL=PinnedVersionsConfiguration.js.map
