import { ServiceScope } from '@microsoft/sp-core-library';
import BaseExtension from './BaseExtension';
import ExtensionContext, { IExtensionContextParameters } from './ExtensionContext';
/**
 * ExtensionManager manages a collection of extensions and provides APIs to create, dispose
 * and access its managed extensions.
 *
 * @remarks
 * Any application that needs to use extensions, should use ExtensionManager to create those extensions
 * by passing in their componentID and properties. ExtensionManager takes care of loading modules and
 * creating the instances for the extensions and provides APIs to manage the created extensions.
 *
 * @internal
 */
export default class ExtensionManager<TExtension extends BaseExtension<{}>> {
    private static _logSource;
    private _serviceScope;
    private _extensionPromises;
    private _expectedType;
    /**
     * Creates a new instance of ExtensionManager.
     *
     * @remarks
     * If you construct an instance of this class, you must dispose it by calling ExtensionManager.dispose();
     * otherwise resource leaks may occur.
     *
     * @param serviceScope - The serviceScope provided by the caller application
     * @param expectedType - for validation purposes, a base class that the resulting object
     *   is expected to extend
     */
    constructor(serviceScope: ServiceScope, expectedType: Function);
    /**
     * Creates an extension instance by loading its module based on the provided componentId and then creates an instance
     * of the extension by passing in the provided properties JSON and context creator.
     *
     * @remarks
     * The provided componentId is a Guid that identifies the module containing the extension (as its default export).
     * The module loader of SharePoint Framework will load the module if its manifest is found on the page
     * (for example, if the extension is installed) and create an instace of the extension and initialize it using
     * the provided contextCreator and propertiesJson. Since this process is asynchronous, the manager returns a promise
     * that resolves once the extension instance is ready.
     *
     * The extension will be disposed by ExtensionManager.dispose().
     *
     * @param componentId - the client-side component ID for the extension.
     * @param propertiesJson - a text string containing an optional JSON object.
     * @param contextCreator - a callback function that constructs an appropriate ExtensionContext
     */
    createExtension(componentId: string, propertiesJson: string | undefined, contextCreator: (extensionContextParameters: IExtensionContextParameters) => ExtensionContext): Promise<TExtension>;
    /**
     * For all extensions that have been created so far by createExtension(), this waits
     * for them all to finish initializing, and then returns the list of initialized extension
     * objects.
     */
    waitForInitialization(): Promise<TExtension[]>;
    /**
     * Disposes any extensions that were created via createExtension().  This is performed by calling
     * BaseExtension.dispose() for each extension.
     */
    dispose(): void;
    /**
     * Creates a new extra data object for writing unexpected failures to QosMonitor.
     */
    private _createQosExtraData(alias, isInternal, manifestId);
}
