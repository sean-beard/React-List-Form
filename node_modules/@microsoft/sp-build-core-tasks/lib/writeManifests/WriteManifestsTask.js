"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var fs = require("fs");
var _ = require("lodash");
var merge = require("merge2");
var path = require("path");
var os_1 = require("os");
var manifestSchemaValidator_1 = require("@microsoft/sp-module-interfaces/lib/manifestSchemaValidator");
var FileUtils_1 = require("./../utilities/FileUtils");
var OdspGulpTask_1 = require("./../OdspGulpTask");
var cumulativeManifestProcessor_1 = require("./../cumulativeManifestProcessor");
var url_1 = require("./../utilities/url");
var normalizeLocaleName_1 = require("./../utilities/normalizeLocaleName");
var constants_1 = require("./../constants");
var schemaPropertyName = '$schema';
/**
 * Writes a manifest for each entry in the project.
 *
 * Example:
 *  IN:
 *   the result of the prepareDeploy step enumerating each entry, each entry's dependencies, and a developer-generated
 *    base manifest for each entry.
 *
 *  OUT:
 *   a debug and, optionally, a production manifest for each entry.
 */
var WriteManifestsTask = (function (_super) {
    __extends(WriteManifestsTask, _super);
    function WriteManifestsTask() {
        var _this = _super.call(this, 'write-manifests', {
            deployCdnPath: undefined,
            debugLocale: constants_1.default.defaultLocale,
            cdnUrlPrefix: undefined,
            cdnBasePath: undefined,
            cumulativeManifestOptions: {
                ignoreOutputManifestIds: undefined
            }
        }) || this;
        // tslint:disable-next-line:no-any
        _this._localizedResourcesCache = {};
        return _this;
    }
    WriteManifestsTask.prototype.loadSchema = function () {
        return require('./write-manifests.schema.json');
    };
    WriteManifestsTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.properties.deployEntries || this.properties.deployEntries.length === 0) {
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('No deploy entries specified. No manifests to write.');
            completeCallback();
            return;
        }
        var shouldProduceDebugManifests = !!this.taskConfig.debugBasePath;
        if (!this.taskConfig.debugBasePath) {
            this.log('Debug base path not specified. Unable to produce debug manifests.');
        }
        var shouldProduceProductionManifests = this.buildConfig.production && !!this.taskConfig.cdnBasePath;
        if (this.buildConfig.production && !this.taskConfig.cdnBasePath) {
            this.logWarning('CDN base path not specified. Unable to produce production manifests.');
        }
        if (this.buildConfig.production && !this.taskConfig.deployCdnPath) {
            shouldProduceProductionManifests = false;
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('CDN deploy path not specified. Unable to produce production manifests.');
        }
        this.taskConfig.debugLocale = normalizeLocaleName_1.default(this.taskConfig.debugLocale);
        this.logVerbose("Using debug locale: " + this.taskConfig.debugLocale);
        var debugManifests = [];
        var manifestIds = {};
        var tasks = [];
        this.properties.deployEntries.forEach(function (deployEntry) {
            var componentKeys = Object.keys(deployEntry.bundleEntry.components);
            componentKeys.forEach(function (id) {
                var bundleComponent = deployEntry.bundleEntry.components[id];
                if (componentKeys.length === 1) {
                    // Only one component - we don't care about the ID
                    id = undefined;
                }
                if (!bundleComponent.manifestData) {
                    _this.logWarning("Manifest not defined for entry \"" + deployEntry.entryName + "\".");
                    return;
                }
                var validationResult = manifestSchemaValidator_1.default.validateManifest(JSON.stringify(bundleComponent.manifestData));
                if (!validationResult.result) {
                    var errorText = manifestSchemaValidator_1.default.getFormattedErrorMessage(validationResult.errors);
                    var manifestPath = bundleComponent.manifest;
                    _this.logError("Manifest validation error (" + manifestPath + "): " + os_1.EOL + errorText);
                    return;
                }
                // Ensure we don't have a duplicate ID
                var lowercaseId = bundleComponent.manifestData.id.toLowerCase();
                if (lowercaseId in manifestIds) {
                    _this.logError("Duplicate manifest ID \"" + lowercaseId + "\". Exists in \"" + manifestIds[lowercaseId].manifest + "\" " +
                        ("and \"" + bundleComponent.manifest + "\"."));
                }
                else {
                    manifestIds[lowercaseId] = bundleComponent;
                }
                if (shouldProduceDebugManifests) {
                    bundleComponent.manifestData =
                        _this._getLocalizedManifest(bundleComponent.manifestData, _this.taskConfig.debugLocale);
                    var loaderConfig = _this._generateLoaderConfig(id, deployEntry.debugModules, [_this.taskConfig.debugBasePath], _this._resolveDebugPath.bind(_this), 
                    // Keep the default path the same between CDN and debug manifests during a
                    //  production build
                    _this.buildConfig.production ? undefined : _this.taskConfig.debugLocale);
                    var debugManifest = _this._generateManifest(bundleComponent, loaderConfig);
                    _this._doFinalManifestFixup(debugManifest);
                    debugManifests.push(debugManifest);
                    tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(debugManifest, undefined, 2), debugManifest.id + ".manifest.json")
                        .pipe(gulp.dest(_this.buildConfig.distFolder)));
                }
                if (shouldProduceProductionManifests) {
                    bundleComponent.manifestData = _this._getLocalizedManifest(bundleComponent.manifestData);
                    var loaderConfig = _this._generateLoaderConfig(id, deployEntry.productionModules, [_this.taskConfig.cdnBasePath], _this._resolveProductionPath.bind(_this));
                    var productionManifest = _this._generateManifest(bundleComponent, loaderConfig);
                    _this._doFinalManifestFixup(productionManifest);
                    var cdnManifest = void 0;
                    if (_this.taskConfig.postProcessProductionManifestFunction) {
                        cdnManifest = _this.taskConfig.postProcessProductionManifestFunction(productionManifest);
                    }
                    else {
                        cdnManifest = productionManifest;
                    }
                    tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(cdnManifest), productionManifest.id + ".json")
                        .pipe(gulp.dest(_this.taskConfig.deployCdnPath)));
                }
            });
        });
        merge(tasks).on('finish', function () {
            // Once this project's manifests are written, crawl the dependency tree discovering manifest files
            if (shouldProduceDebugManifests) {
                var cumulativeManifestOptions = _this.taskConfig.cumulativeManifestOptions;
                cumulativeManifestOptions.baseUrl = _this.taskConfig.debugBasePath;
                var cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(_this, cumulativeManifestOptions);
                merge(cumulativeManifestProcessor.generateCumulativeManifest(gulp, debugManifests))
                    .on('finish', function () { return completeCallback(); });
            }
            else {
                completeCallback();
            }
        });
    };
    /**
     * Localizes a manifest. Only works with WebPart and Application manifests,
     * otherwise it does nothing
     */
    WriteManifestsTask.prototype._getLocalizedManifest = function (manifest, defaultLocale) {
        var manifestClone = _.cloneDeep(manifest);
        switch (manifestClone.componentType) {
            case 'WebPart':
                // tslint:disable-next-line:no-any
                this._localizeWebPartManifest(manifestClone, defaultLocale);
                break;
            case 'Application':
                this._localizeApplicationManifest(manifestClone, defaultLocale);
                break;
            case 'Extension':
                this._localizeExtensionsManifest(manifestClone, defaultLocale);
                break;
        }
        return manifestClone;
    };
    /**
     * Perform some final fixup on manifests.
     */
    WriteManifestsTask.prototype._doFinalManifestFixup = function (manifest) {
        if (manifest.componentType === 'Application') {
            var applicationManifest = manifest;
            if (!applicationManifest.preloadComponents) {
                applicationManifest.preloadComponents = [];
            }
        }
        else if (manifest.componentType === 'Extension') {
            var extensionManifest = manifest;
            if (extensionManifest.extensionType === 'ListViewCommandSet') {
                var commandSetManifest = extensionManifest;
                // Workaround for server issue - make sure the "items" and the "commands" properties have the same value
                if (commandSetManifest.items) {
                    commandSetManifest.commands = commandSetManifest.items;
                }
                else if (commandSetManifest.commands) {
                    commandSetManifest.items = commandSetManifest.commands;
                }
            }
        }
    };
    /**
     * Localizes a WebPart manifest. That includes title, description and group
     * for all preconfigured entries
     */
    // tslint:disable-next-line:no-any
    WriteManifestsTask.prototype._localizeWebPartManifest = function (manifest, defaultLocale) {
        var _this = this;
        // tslint:disable-next-line:no-any
        manifest.preconfiguredEntries.forEach(function (entry) {
            entry.title = _this._localizeString(entry.title, defaultLocale);
            entry.description = _this._localizeString(entry.description, defaultLocale);
            if (entry.group) {
                entry.group = _this._localizeString(entry.group, defaultLocale);
            }
        });
    };
    /**
     * Localizes an Application manifest. This includes title and description of the Application
     */
    WriteManifestsTask.prototype._localizeApplicationManifest = function (manifest, defaultLocale) {
        manifest.title = this._localizeString(manifest.title, defaultLocale);
        manifest.description = this._localizeString(manifest.description, defaultLocale);
    };
    /**
     * Localizes an Extension manifest. This includes the "title" and "ariaLabel" fields for items in
     *  command set extensions.
     */
    WriteManifestsTask.prototype._localizeExtensionsManifest = function (manifest, defaultLocale) {
        switch (manifest.extensionType) {
            case 'ListViewCommandSet':
                var commandSetManifest = manifest;
                for (var itemId in commandSetManifest.items) {
                    if (commandSetManifest.items.hasOwnProperty(itemId)) {
                        var item = commandSetManifest.items[itemId];
                        item.title = this._localizeString(item.title, defaultLocale);
                        if (item.ariaLabel) {
                            item.ariaLabel = this._localizeString(item.ariaLabel, defaultLocale);
                        }
                    }
                }
                break;
            case 'Unknown':
            case 'ApplicationCustomizer':
            case 'FieldCustomizer':
                // No localizable fields.
                break;
        }
    };
    /**
     * Localizes a string with an id in the web $moduleName:expression;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    WriteManifestsTask.prototype._localizeString = function (stringToLocalize, defaultLocale) {
        // If there is no id, assume the property is either not localized, or the localized values are
        //  hardcoded.
        if (!stringToLocalize.id) {
            return stringToLocalize;
        }
        var regex = /^(?:\$)([^:]+)(?:\:)(.+)(?:\;)$/; // Test $<name>:<expr>;
        var matches = stringToLocalize.id.match(regex);
        if (matches && matches.length === 3) {
            this.logVerbose("Localizing string '" + matches[0] + "'");
            var localizedStrings = this._localizeStringInternal(
            /* resourceName */ matches[1], 
            /* expression */ matches[2], 
            /* stringId */ matches[0]);
            if (defaultLocale) {
                if (!(localizedStrings['default'] = localizedStrings[defaultLocale])) {
                    this.logError("Unable to set default locale to \"" + defaultLocale + "\". "
                        + "Ensure that resources exist for this locale.");
                }
            }
            return localizedStrings;
        }
        else {
            this.logError("String id '" + stringToLocalize.id + "' has wrong format. It is not $<moduleName>:<expression>;");
            // Return an empty ILocalizedString
            return {
                default: ''
            };
        }
    };
    /**
     * Localizes a string where it's been verified that the id follows the schema.
     * @param resourceName Name of the resource to load
     * @param expression Expression to be evaluated on the resource
     * @stringId Original id for the string. Used for logging purposes only
     * @returns Localized string with all found locales
     */
    WriteManifestsTask.prototype._localizeStringInternal = function (resourceName, expression, stringId) {
        var localizedString = {
            default: ''
        };
        var resources = this.properties.discoveredLocalizedResources[resourceName];
        if (resources) {
            for (var locale in resources) {
                var resource = this._getResource(resources[locale]); // tslint:disable-line:no-any
                var normalizedLocaleName = normalizeLocaleName_1.default(locale);
                if (resource) {
                    var evalString = expression.replace(resourceName, 'r');
                    var stringFromExpression = undefined;
                    try {
                        /* tslint:disable:no-any */
                        // tslint:disable-next-line:no-unused-variable
                        var shallowDiscoverProperty = function (resourceData, propertyName) {
                            /* tslint:enable:no-any */
                            var foundBuckets = [];
                            var firstFoundValue;
                            for (var bucketName in resourceData) {
                                if (resourceData[bucketName] && resourceData[bucketName][propertyName]) {
                                    firstFoundValue = resourceData[bucketName][propertyName];
                                    foundBuckets.push(bucketName);
                                }
                            }
                            if (!firstFoundValue) {
                                throw new Error("A value for a property \"" + propertyName + "\" was not found inside any " +
                                    "property of the resource object.");
                            }
                            if (foundBuckets.length !== 1) {
                                throw new Error("A value for a property \"" + propertyName + "\" was found inside multiple " +
                                    "properties of the resource object and must be disambiguated to be selected.");
                            }
                            return firstFoundValue;
                        };
                        // We support any format for the localized resource,
                        // so we rely on the developer telling the code how to access it.
                        // Eval generates risk. In order to minimize it, only one expression is allowed.
                        // tslint:disable-next-line:no-eval
                        stringFromExpression = eval('function getLocalizedString(r) {' +
                            'return ' + evalString +
                            '}' +
                            'getLocalizedString(resource)');
                    }
                    catch (error) {
                        this.logWarning("Problem extracting id '" + stringId + "' in locale '" + normalizedLocaleName + "'. " +
                            ("Error: " + error));
                    }
                    if (stringFromExpression) {
                        localizedString[normalizedLocaleName] = stringFromExpression;
                    }
                    else {
                        this.logWarning("Couldn't find id '" + stringId + "' in locale '" + normalizedLocaleName + "'");
                    }
                }
            }
        }
        else {
            this.logError("Localized module '" + resourceName + "' not found");
        }
        return localizedString;
    };
    /**
     * Gets a resource file from a path.
     */
    // tslint:disable-next-line:no-any
    WriteManifestsTask.prototype._getResource = function (resourcePath) {
        if (!this._localizedResourcesCache[resourcePath]) {
            this._cacheResource(resourcePath);
        }
        return this._localizedResourcesCache[resourcePath];
    };
    /**
     * Caches a resource file from a path.
     * Because this execute in the build tools, function define is not defined,
     * so a fake function is created that will return the default element of the module.
     */
    WriteManifestsTask.prototype._cacheResource = function (resourcePath) {
        // Fake a define method to get the localizedResource module
        // tslint:disable-next-line:no-unused-variable no-any
        function define(name, deps, callback) {
            if (typeof name !== 'string') {
                callback = deps;
                deps = name;
                name = undefined;
            }
            if (!Array.isArray(deps)) {
                callback = deps;
                deps = undefined;
            }
            var exports = {}; // tslint:disable-line:no-any
            var result = callback([undefined, exports]); // tslint:disable-line:no-any
            return result.default || result || exports.default;
        }
        try {
            // We can't get the localized module dynamically at this point.
            // Reading and executing the module file in order to get the module
            var resourcesFile = fs.readFileSync(resourcePath, 'utf8');
            // tslint:disable-next-line:no-eval
            var resource = eval(resourcesFile); // tslint:disable-line:no-any
            this._localizedResourcesCache[resourcePath] = resource;
        }
        catch (error) {
            this.logError("Can't get resource '" + resourcePath + "'. " +
                "Check that the module is correct and has doesn't require any external module.");
        }
    };
    WriteManifestsTask.prototype._generateManifest = function (bundleComponent, loaderConfig) {
        var manifest = lodash_1.cloneDeep(bundleComponent.manifestData);
        delete manifest[schemaPropertyName];
        manifest.loaderConfig = loaderConfig;
        return manifest;
    };
    WriteManifestsTask.prototype._generateLoaderConfig = function (entrypointExportName, deployModules, internalModuleBaseUrls, resolvePath, defaultLocaleOverride) {
        var scriptResources = {};
        if (deployModules.pathModules) {
            deployModules.pathModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'path';
                scriptResources[id] = module;
                module.path = resolvePath(module.path);
            });
        }
        if (deployModules.localizedPathModules) {
            deployModules.localizedPathModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'localizedPath';
                scriptResources[id] = module;
                var oldPaths = module.paths;
                module.paths = {};
                var lowercaseLocales = {};
                for (var locale in oldPaths) {
                    var resourcePath = oldPaths[locale];
                    var lowercaseLocale = locale.toLowerCase();
                    var normalizedLocale = normalizeLocaleName_1.default(lowercaseLocale);
                    lowercaseLocales[lowercaseLocale] = normalizedLocale;
                    module.paths[normalizedLocale] = resolvePath(resourcePath);
                }
                var lowercaseDefaultLocaleOverride = (defaultLocaleOverride && defaultLocaleOverride.toLowerCase)
                    ? defaultLocaleOverride.toLowerCase()
                    : undefined;
                if (lowercaseDefaultLocaleOverride && lowercaseDefaultLocaleOverride in lowercaseLocales) {
                    module.defaultPath = module.paths[lowercaseLocales[lowercaseDefaultLocaleOverride]];
                    if (Object.keys(module.paths).length <= 1) {
                        // Delete the paths object if the only built path is the default
                        delete module.paths;
                    }
                }
                else {
                    module.defaultPath = resolvePath(module.defaultPath);
                }
            });
        }
        if (deployModules.componentModules) {
            deployModules.componentModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'component';
                scriptResources[id] = module;
                if (module.failoverPath) {
                    module.failoverPath = resolvePath(module.failoverPath);
                }
            });
        }
        if (!(deployModules.entryModuleId in scriptResources)) {
            this.logError("Entry module \"" + deployModules.entryModuleId + "\" is missing a definition. The manifest will not " +
                'load');
        }
        var result = {
            entryModuleId: deployModules.entryModuleId,
            internalModuleBaseUrls: internalModuleBaseUrls.map(function (url) { return url_1.ensureTrailingSlash(url); }),
            scriptResources: scriptResources
        };
        if (entrypointExportName) {
            result.exportName = entrypointExportName;
        }
        return result;
    };
    WriteManifestsTask.prototype._resolveDebugPath = function (assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            // If this is a full URL, don't change it
            if (url_1.isUrl(assetPath)) {
                return assetPath;
            }
            else {
                return path.relative(this.buildConfig.rootPath, assetPath).replace(/\\/g, '/');
            }
        }
        else {
            return {
                default: this._resolveDebugPath(assetPath.default),
                debug: this._resolveDebugPath(assetPath.debug)
            };
        }
    };
    WriteManifestsTask.prototype._resolveProductionPath = function (assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            var assetPathStr = assetPath;
            // If this is a full URL, don't change it
            if (url_1.isUrl(assetPathStr)) {
                return assetPathStr;
            }
            else if (this.taskConfig.cdnUrlPrefix) {
                return url_1.joinUrlSegments(this.taskConfig.cdnUrlPrefix, assetPathStr);
            }
            else {
                return url_1.trimLeadingSlashes(assetPathStr);
            }
        }
        else {
            return {
                default: this._resolveProductionPath(assetPath.default),
                debug: this._resolveProductionPath(assetPath.debug)
            };
        }
    };
    return WriteManifestsTask;
}(OdspGulpTask_1.default));
exports.WriteManifestsTask = WriteManifestsTask;

//# sourceMappingURL=WriteManifestsTask.js.map
