"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var cumulativeManifestProcessor_1 = require("./../cumulativeManifestProcessor");
var Resolve_1 = require("./../utilities/Resolve");
var _nonStandardExternalMapIsInitialized = false;
var _nonStandardExternalMap = {
    'react': {
        name: 'react',
        version: undefined,
        id: '0d910c1c-13b9-4e1c-9aa4-b008c5e42d7d',
        getFailoverPath: function (packageRoot) { return path.join(packageRoot, 'dist', 'react.js'); },
        getVersion: getVersionFunction('react')
    },
    'react-dom': {
        name: 'react-dom',
        version: undefined,
        id: 'aa0a46ec-1505-43cd-a44a-93f3a5aa460a',
        getFailoverPath: function (packageRoot) { return path.join(packageRoot, 'dist', 'react-dom.js'); },
        getVersion: getVersionFunction('react-dom')
    }
};
/**
 * Get an array of a project's externals' names. To be used when creating a webpack configuration.
 */
// tslint:disable-next-line:no-any
function getExternalsKeys(gulpTask) {
    // Set the linked externals if they aren't already set
    setLinkedExternals(gulpTask);
    var result = [];
    result.push.apply(result, Object.keys(gulpTask.properties.linkedExternals));
    if (gulpTask.properties.externals) {
        result.push.apply(result, Object.keys(gulpTask.properties.externals));
    }
    return result;
}
exports.getExternalsKeys = getExternalsKeys;
/**
 * Set the linked externals in the task's shared properties object if it isn't already set
 */
// tslint:disable-next-line:no-any
function setLinkedExternals(gulpTask) {
    if (!gulpTask.properties.linkedExternals) {
        var linkedExternals = _getLinkedExternals(gulpTask);
        gulpTask.properties.linkedExternals = linkedExternals;
    }
}
exports.setLinkedExternals = setLinkedExternals;
function includeNonStandardExternal(name, external) {
    if (_nonStandardExternalMapIsInitialized) {
        throw new Error('The non-standard external map has already been initialized, which means it\'s probably already ' +
            'been used. Adding an additional non-standard external is likely to not have any effect.');
    }
    _nonStandardExternalMap[name] = external;
}
exports.includeNonStandardExternal = includeNonStandardExternal;
/**
 * Gets the referenced externals for a project.
 */
// tslint:disable-next-line:no-any
function _getLinkedExternals(gulpTask) {
    // Discover packages that should be externalized because they have manifests
    var cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(gulpTask);
    var discoveredManifests = cumulativeManifestProcessor.discoverManifests(process.cwd(), cumulativeManifestProcessor_1.ForceSearch.deepSparseIgnoreFirstProject);
    var result = {};
    // Add these projects to externalized packages
    for (var manifestId in discoveredManifests) {
        var referencedProject = discoveredManifests[manifestId];
        if (referencedProject.packageName) {
            result[referencedProject.packageName] = {
                id: manifestId,
                name: referencedProject.packageName,
                version: referencedProject.manifestData.version
            };
        }
    }
    var nonStandardExternals = _getNonStandardExternals(gulpTask.buildConfig.rootPath);
    for (var externalName in nonStandardExternals) {
        result[externalName] = nonStandardExternals[externalName];
    }
    return result;
}
/**
 * This is a temporary function that will soon be replaced by something more robust. It
 *  currently serves to include linked externals referenced in projects that don't have manifests.
 */
function _getNonStandardExternals(projectRootPath) {
    var result = {};
    _initializeNonStandardExternalMap(projectRootPath);
    for (var dependency in _nonStandardExternalMap) {
        _tryFillFailoverPath(projectRootPath, _nonStandardExternalMap[dependency]);
        result[dependency] = _nonStandardExternalMap[dependency];
    }
    return result;
}
function _initializeNonStandardExternalMap(projectRootPath) {
    if (!_nonStandardExternalMapIsInitialized) {
        for (var packageName in _nonStandardExternalMap) {
            if (_nonStandardExternalMap.hasOwnProperty(packageName)) {
                var project = _nonStandardExternalMap[packageName];
                project.version = project.getVersion(projectRootPath) || '';
            }
        }
        _nonStandardExternalMapIsInitialized = true;
    }
}
function getVersionFunction(packageName) {
    return function (projectRootPath) {
        try {
            var resolvedPath = Resolve_1.resolvePackage(packageName, projectRootPath);
            if (resolvedPath) {
                var packageJson = require(path.join(resolvedPath, 'package.json'));
                var version = packageJson.version;
                var matches = version.match(/([^-]*)(?:.*)/);
                return matches[1];
            }
        }
        catch (e) {
            return undefined;
        }
    };
}
exports.getVersionFunction = getVersionFunction;
function _tryFillFailoverPath(projectRootPath, dependency) {
    if (!dependency.failoverPath && dependency.getFailoverPath) {
        try {
            var resolvedPath = Resolve_1.resolvePackage(dependency.name, projectRootPath);
            dependency.failoverPath = dependency.getFailoverPath(resolvedPath);
        }
        catch (e) { }
    }
}

//# sourceMappingURL=ExternalsProcessor.js.map
