/// <reference types="node" />
import * as Gulp from 'gulp';
import { IComponentModuleConfiguration, IPathModuleConfiguration, ILocalizedPathModuleConfiguration } from '@microsoft/sp-module-interfaces';
import { default as OdspGulpTask } from './../OdspGulpTask';
import { IBundleEntry } from './../configureWebpack/ConfigureWebpackTask';
export declare const externalsRegex: RegExp;
export interface ICopyAssetsTaskConfig {
    /**
     * Path to where assets should be staged for deployment to CDN during a production build
     */
    deployCdnPath?: string;
    /**
     * Extensions of webpack-produced assets to ignore
     */
    extsToIgnore?: string[];
    /**
     * If true, production builds will no longer generate file names that have a hash. Defaults to false.
     */
    excludeHashFromFileNames?: boolean;
    /**
     * If true, production builds will place localized files in directories named according to the locale. For example
     *  an output file called "my-component.js" will be written to "<deployCdnPath>/my-component_en-us-<hash>.js" if this
     *  property is false and it will be written to "<deployCdnPath>/en-us/my-component-<hash>.js" if this property
     *  is true. Non-localized resources will be placed in the same directory regardless of whether this property is true
     *  or false. Defaults to false.
     */
    localeInDirectoryName?: boolean;
}
export interface IWebpackStatsObject {
    assets: IWebpackAsset[];
    chunks: IWebpackChunk[];
    modules: IWebpackModule[];
}
export interface IWebpackAsset {
    name: string;
    chunks: number[];
}
export interface IWebpackChunk {
    entry: boolean;
    id: number;
    files: string[];
    names: string[];
    hash: string;
    size: number;
}
export interface IWebpackModule {
    name: string;
    chunks: number[];
}
export interface IDeployEntry {
    bundleEntry: IBundleEntry;
    entryName?: string;
    debugModules?: IDeployModules;
    productionModules?: IDeployModules;
}
export interface IDeployModules {
    entryModuleId?: string;
    localizedPathModules: Map<string, ILocalizedPathModuleConfiguration>;
    pathModules: Map<string, IPathModuleConfiguration>;
    componentModules: Map<string, IComponentModuleConfiguration>;
}
/**
 * Prepares deployment to CDNs and the manifest server through onedrive-buildtools.
 *
 * Example:
 *  IN:
 *   webpack stats
 *   deployCdnPath - a path where files should be placed for upload to CDNs and the manifest server
 *
 *  OUT:
 *   all assets for the package copied to {deployCdnPath}
 *   all externals for the package copied to {deployCdnPath}
 *   data required to produce manifests in the properties object
 */
export declare class CopyAssetsTask extends OdspGulpTask<ICopyAssetsTaskConfig> {
    constructor();
    loadSchema(): Object;
    executeTask(gulp: typeof Gulp, completeCallback: (error?: string) => void): NodeJS.ReadWriteStream;
    private _copyStrings(gulp, stringsCopyCallbackMap, tasks);
    private _processEntry(gulp, deployEntry, shouldPrepareProductionDeployment, stringsModuleId, tasks);
    private _transformBundleHeader(entryGulpStream, bundleEntry);
    private _processExternals(gulp, externalModules, tasks);
    private _processExternalsForEntry(webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap);
    private _selectDefaultLocaleForResource(paths, externalName);
    private _fillLocalizedPaths(paths, defaultLocale, moduleConfig);
    private _fillLocalizedPath(localizedPath, locale, defaultLocale, moduleConfig);
    /**
     * For webpack entries that are imported using SystemJS, the script is injected into the page, but
     * the element is removed before the entry is initialized. Webpack requires a public path be set,
     * and because we don't have a single host location, we need to set the public path dynamically.
     * The public path is set when the entry is initialized, and in certain cases (like in development),
     * it will look at the script tags on the page to determine what the root path is.
     *
     * We can append a small bit of code to the end of the entry's JS file that will mitigate this issue
     * by maintaining a registry of scripts that have been injected onto the page, so the public path
     * can be correctly set even if the script element that pointed to the entry's JS file has been removed
     * already.
     */
    private _insertGlobalRegisterCodeIfNecessary(self, debug);
}
