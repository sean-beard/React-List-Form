"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var glob = require("glob");
var Webpack = require("webpack");
var fsx = require("fs-extra");
var rush_lib_1 = require("@microsoft/rush-lib");
var OdspGulpTask_1 = require("./../OdspGulpTask");
var cumulativeManifestProcessor_1 = require("./../cumulativeManifestProcessor");
var deployToAzure_1 = require("./../deployAzureStorage/uploadCDN/deployToAzure");
var ensureBlobService_1 = require("./../utilities/azureStorage/ensureBlobService");
var ensureContainer_1 = require("./../utilities//azureStorage/ensureContainer");
var uploadFileToAzure_1 = require("./../utilities//azureStorage/uploadFileToAzure");
var url_1 = require("./../utilities/url");
var RetryablePromise_1 = require("./../utilities/RetryablePromise");
var DevDeployLinkPrinter_1 = require("./DevDeployLinkPrinter");
var MANIFESTS_AZURE_FILENAME = 'manifests.js';
var SP_LOADER_ASSEMBLY_ID = '44bae1a2-d2eb-4e10-8c21-a1dbdce1036f';
var MAX_UPLOAD_RETRIES = 3;
var RETRY_DELAY_MS = 250;
var SOURCE_BRANCH_ENV_VAR_NAME = 'BUILD_SOURCEBRANCH';
var DevDeployTask = (function (_super) {
    __extends(DevDeployTask, _super);
    function DevDeployTask() {
        return _super.call(this, 'dev-deploy', {
            useRush: false,
            isolateProjects: true
        }) || this;
    }
    DevDeployTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.taskConfig.account) {
            completeCallback('Azure storage account not set.');
            return;
        }
        if (!this.taskConfig.accessKey) {
            completeCallback('Azure storage account access key not set.');
            return;
        }
        if (!this.taskConfig.container) {
            completeCallback('Azure container name not set.');
            return;
        }
        if (!this.taskConfig.containerDirectoryName) {
            this.logWarning('It is strongly recommended a directory inside the container be used to avoid clobbering other ' +
                'users\' dev deployments.');
        }
        this.taskConfig.useRush = this.taskConfig.useRush || (process.argv.indexOf('--rush') !== -1);
        if (process.argv.indexOf('--ciMode') !== -1) {
            var branchName = process.env[SOURCE_BRANCH_ENV_VAR_NAME];
            var containerDirectoryName = branchName
                ? branchName.replace(/[^A-Za-z0-9\-]+/g, '_')
                : this.taskConfig.containerDirectoryName + "_tab";
            this.setConfig({
                containerDirectoryName: containerDirectoryName,
                useRush: true,
                isolateProjects: false
            });
        }
        var cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(this, { explicitInclude: [SP_LOADER_ASSEMBLY_ID] });
        var manifests;
        try {
            manifests = this._getManifests(cumulativeManifestProcessor);
        }
        catch (e) {
            completeCallback(e);
            return;
        }
        var manifestsArray = [];
        this.logVerbose("Discovered " + Object.keys(manifests).length + " projects.");
        var storageDirName = this._getStorageDirName();
        var containerUrl = this._getContainerUrl();
        var filesToUpload = new Map();
        var dirsToUpload = new Map();
        var projectContainerNames = new Map(); // Ensure we don't reuse a name
        var spLoaderPath;
        var debugSPLoader;
        var _loop_1 = function (id) {
            if (manifests.hasOwnProperty(id)) {
                var manifestProject_1 = manifests[id];
                var manifest = manifestProject_1.manifestData;
                var loaderConfig = manifest.loaderConfig;
                manifestsArray.push(manifest);
                var projectContainerName = this_1.taskConfig.isolateProjects
                    ? this_1._getAzureDirName(projectContainerNames, manifestProject_1.packagePath)
                    : '';
                var projectBasePath_1 = url_1.joinUrlSegments(storageDirName, projectContainerName);
                var projectBaseFullUrl = url_1.joinUrlSegments(containerUrl, projectBasePath_1);
                loaderConfig.internalModuleBaseUrls = [url_1.ensureTrailingSlash(projectBaseFullUrl)];
                // Ensure we don't reuse a name
                var resourceContainerNames_1 = new Map();
                var processPath = function (rawResourcePath) {
                    var resourcePath = _this._disambiguatePath(rawResourcePath);
                    if (url_1.isUrl(resourcePath)) {
                        return resourcePath; // Do not deal with fully-qualified URL.
                    }
                    else {
                        var filesystemPath = path.join(manifestProject_1.packagePath, resourcePath);
                        var filename = path.basename(resourcePath);
                        // Path resources are in the 'dist' directory by default and usually have some secondary
                        //  references, so let's just upload the whole directory.
                        var filesystemDirectory = path.dirname(filesystemPath);
                        var azureResourceDirName = _this.taskConfig.isolateProjects
                            ? _this._getAzureDirName(resourceContainerNames_1, filesystemDirectory) :
                            '';
                        var azureDirectory = url_1.joinUrlSegments(projectBasePath_1, azureResourceDirName);
                        dirsToUpload.set(filesystemDirectory, azureDirectory);
                        if (!spLoaderPath && id === SP_LOADER_ASSEMBLY_ID) {
                            spLoaderPath = azureDirectory;
                            debugSPLoader = filename;
                        }
                        return url_1.joinUrlSegments(azureResourceDirName, filename);
                    }
                };
                for (var scriptResourceId in loaderConfig.scriptResources) {
                    if (loaderConfig.scriptResources.hasOwnProperty(scriptResourceId)) {
                        var scriptResource = loaderConfig.scriptResources[scriptResourceId];
                        switch (scriptResource.type) {
                            case 'path':
                                // Path script resource, we need to fix up its path and upload it
                                var pathResource = scriptResource;
                                pathResource.path = processPath(pathResource.path);
                                break;
                            case 'component':
                                // We probably don't need to upload the fallback file, and it's nigh-impossible to tell if we'll
                                //  miss secondary dependencies by only uploading the file at the failoverPath, so we'll just clear it
                                //  out and hope this dependency is either satisfied by another dev-deploy manifest or by the OOB
                                //  framework
                                var componentResource = scriptResource;
                                componentResource.failoverPath = undefined;
                                break;
                            case 'localizedPath':
                                // Localized path script resource, we need to fix up the paths for each locale and upload each file
                                var localizedPathResource = scriptResource;
                                localizedPathResource.defaultPath = processPath(localizedPathResource.defaultPath);
                                if (localizedPathResource.paths) {
                                    for (var locale in localizedPathResource.paths) {
                                        if (localizedPathResource.paths.hasOwnProperty(locale)) {
                                            localizedPathResource.paths[locale] = processPath(localizedPathResource.paths[locale]);
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }
        };
        var this_1 = this;
        // Loop through the manifests and collect files and directories to be uploaded, and fix up manifest fields
        for (var id in manifests) {
            _loop_1(id);
        }
        // Expand directories to individual files
        var directoryExpandPromises = [];
        var collisionDetectionMap = new Map();
        dirsToUpload.forEach(function (azureDirName, localDirName) {
            directoryExpandPromises.push(_this._getFilesInDirectory(localDirName).then(function (files) {
                files.forEach(function (file) {
                    var azureUrl = url_1.joinUrlSegments(azureDirName, file.replace(/\\/g, '/'));
                    var localPath = path.join(localDirName, file);
                    if (fsx.statSync(localPath).isDirectory()) {
                        return; // Continue on directories
                    }
                    if (!_this.taskConfig.isolateProjects) {
                        if (collisionDetectionMap.has(azureUrl)) {
                            collisionDetectionMap.get(azureUrl).push(localPath);
                        }
                        else {
                            collisionDetectionMap.set(azureUrl, [localPath]);
                        }
                    }
                    filesToUpload.set(localPath, azureUrl);
                });
            }));
        });
        var blobServicePromise = ensureBlobService_1.default(this.taskConfig.account, this.taskConfig.accessKey)
            .then(function (blobService) { return ensureContainer_1.default(blobService, _this.taskConfig.container, 
        /* createContainerOptions */ undefined, _this.log.bind(_this)); });
        var uploadPromise = blobServicePromise.then(function (blobService) {
            return Promise.all(directoryExpandPromises).then(function () {
                var uploadPromises = [];
                filesToUpload.forEach(function (azurePath, localFile) {
                    uploadPromises.push(uploadFileToAzure_1.default(blobService, _this.taskConfig.container, localFile, azurePath, _this.log.bind(_this)));
                });
                return RetryablePromise_1.default.allWithRetries(uploadPromises, MAX_UPLOAD_RETRIES, RETRY_DELAY_MS);
            });
        });
        var manifestsFilePromise = uploadPromise.then(function (blobServices) {
            var blobService = blobServices[0];
            var webpackConfig = cumulativeManifestProcessor.getManifestsFileWebpackConfig(manifestsArray);
            var manifestsFilename = 'devDeployManifests.js';
            var manifestsFileFullPath = path.join(webpackConfig.output.path, manifestsFilename);
            webpackConfig.output.filename = manifestsFilename;
            return new Promise(function (resolve, reject) {
                Webpack(webpackConfig, function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            }).then(function () {
                return RetryablePromise_1.default.allWithRetries([uploadFileToAzure_1.default(blobService, _this.taskConfig.container, manifestsFileFullPath, url_1.joinUrlSegments(storageDirName, MANIFESTS_AZURE_FILENAME), _this.log.bind(_this))], MAX_UPLOAD_RETRIES, RETRY_DELAY_MS).then(function (value) { return value[0]; });
            });
        });
        return manifestsFilePromise.then(function () {
            var devDeployUrl = _this.getDeployUrl();
            var loaderUrl = url_1.joinUrlSegments(containerUrl, spLoaderPath, debugSPLoader);
            _this.log('UPLOAD COMPLETE.');
            // Warn about collisions
            collisionDetectionMap.forEach(function (localPaths, url) {
                if (localPaths.length > 1) {
                    _this.logWarning("COLLISION DETECTED: [" + localPaths.join(',') + "] all deployed to the same URL (" + url + "). " +
                        "It is very probable that the dev-deploy will not work as expected. This may indicate a " +
                        "serious issue for production environments as well.");
                }
            });
            DevDeployLinkPrinter_1.printDevDeployLink(_this.log.bind(_this), loaderUrl, devDeployUrl);
            _this.properties.devDeployManifestFileUrl = devDeployUrl;
            _this.properties.devDeployModuleLoaderUrl = loaderUrl;
            completeCallback();
            return {};
        }).catch(function (error) {
            completeCallback(error.message);
            return {};
        });
    };
    DevDeployTask.prototype.getDeployUrl = function () {
        return url_1.joinUrlSegments(this._getContainerUrl(), this._getStorageDirName(), MANIFESTS_AZURE_FILENAME);
    };
    DevDeployTask.prototype._getContainerUrl = function () {
        return deployToAzure_1.getAzureStorageUrl(this.taskConfig.account, this.taskConfig.container);
    };
    DevDeployTask.prototype._getStorageDirName = function () {
        return this.taskConfig.containerDirectoryName || '';
    };
    DevDeployTask.prototype._disambiguatePath = function (pathToDisambiguate) {
        return typeof pathToDisambiguate === 'string'
            ? pathToDisambiguate
            : pathToDisambiguate.default;
    };
    DevDeployTask.prototype._getFilesInDirectory = function (dirName) {
        return new Promise(function (resolve, reject) {
            glob(path.join('**', '*.*'), { cwd: dirName }, function (error, files) {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(files || []);
                }
            });
        });
    };
    /**
     * This function returns a directory name to be used in a directory on Azure storage, ensuring that the name does
     *  not collide with another directory's name. It also ensures that if the specified filesystem path has already
     *  been mapped to an Azure directory, the same name is used on Azure.
     */
    DevDeployTask.prototype._getAzureDirName = function (directoryMap, filesystemPath) {
        var azureDirName = path.basename(filesystemPath).toLowerCase();
        if (directoryMap.has(azureDirName)) {
            var existingPaths = directoryMap.get(azureDirName);
            var currentPathId = existingPaths.indexOf(filesystemPath);
            if (currentPathId === -1) {
                azureDirName = azureDirName + "_" + existingPaths.length;
                existingPaths.push(filesystemPath);
            }
            else if (currentPathId > 0) {
                azureDirName = azureDirName + "_" + currentPathId;
            }
        }
        else {
            directoryMap.set(azureDirName, [filesystemPath]);
        }
        return azureDirName;
    };
    DevDeployTask.prototype._getManifests = function (cumulativeManifestProcessor) {
        if (this.taskConfig.useRush) {
            var rushConfig = rush_lib_1.RushConfiguration.loadFromDefaultLocation();
            if (!rushConfig) {
                throw 'Unable to find the rush configuration file.';
            }
            var manifests = void 0;
            var directories = rushConfig.projects.map(function (proj) { return proj.projectFolder; });
            manifests = cumulativeManifestProcessor.discoverManifests(directories[0], cumulativeManifestProcessor_1.ForceSearch.deepSparse);
            for (var i = 1; i < directories.length; i++) {
                var projectManifests = cumulativeManifestProcessor.discoverManifests(directories[i], cumulativeManifestProcessor_1.ForceSearch.deepSparse);
                manifests = this._mergeReferencedProjectLists(manifests, projectManifests);
            }
            return manifests;
        }
        else {
            return cumulativeManifestProcessor.discoverManifests(this.buildConfig.rootPath, cumulativeManifestProcessor_1.ForceSearch.deepSparse);
        }
    };
    DevDeployTask.prototype._mergeReferencedProjectLists = function (list1, list2) {
        var ids = new Set();
        Object.keys(list1).concat(Object.keys(list2)).forEach(function (id) { return ids.add(id); });
        var result = {};
        ids.forEach(function (id) {
            var list1Element = list1[id];
            var list2Element = list2[id];
            if (!list1Element || !list2Element) {
                // Element is only present in one list
                result[id] = list1Element || list2Element;
            }
            else if (list1Element.manifestCreationTime > list2Element.manifestCreationTime) {
                // List 1's element is newer
                result[id] = list1Element;
            }
            else {
                // List 2's element is newer, or they have the same age
                result[id] = list2Element;
            }
        });
        return result;
    };
    return DevDeployTask;
}(OdspGulpTask_1.default));
exports.DevDeployTask = DevDeployTask;

//# sourceMappingURL=DevDeployTask.js.map
