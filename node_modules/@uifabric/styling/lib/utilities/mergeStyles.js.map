{"version":3,"file":"mergeStyles.js","sourceRoot":"../src/","sources":["utilities/mergeStyles.ts"],"names":[],"mappings":";;AAAA,iCAAmC;AAGnC,+EAA8E;AAE9E;;;;;;;;;;GAUG;AACH;IAA4B,cAA+C;SAA/C,UAA+C,EAA/C,qBAA+C,EAA/C,IAA+C;QAA/C,yBAA+C;;IACzE,IAAM,OAAO,GAAa,EAAE,CAAC;IAC7B,IAAM,KAAK,GAAW,EAAE,CAAC;IAEzB,oBAAoB,OAA+C;QACjE,GAAG,CAAC,CAAc,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO;YAApB,IAAM,GAAG,gBAAA;YACZ,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACR,EAAE,CAAC,CAAC,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC;oBAC5B,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACpB,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC9B,UAAU,CAAC,GAAG,CAAC,CAAC;gBAClB,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,KAAK,CAAC,IAAI,CAAC,GAAW,CAAC,CAAC;gBAC1B,CAAC;YACH,CAAC;SACF;IACH,CAAC;IAED,UAAU,CAAC,IAAI,CAAC,CAAC;IAEjB,IAAI,WAAW,GAAkB,IAAI,CAAC;IAEtC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QACjB,qCAAiB,CAAC,OAAO,CAAC,YAAY,EAAE;YACtC,WAAW,GAAG,YAAG,eAAI,KAAK,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;QACnB,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YAChB,OAAO,CAAC,IAAI,CAAE,WAAsB,CAAC,QAAQ,EAAE,CAAC,CAAC;QACnD,CAAC;QACD,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;IAED,MAAM,CAAC,WAAW,IAAI,EAAE,CAAC;AAC3B,CAAC;AApCD,kCAoCC","sourcesContent":["import { css, Rule } from 'glamor';\r\nimport { IStyle, IProcessedStyle } from '../interfaces/index';\r\n\r\nimport { FabricPerformance } from '@uifabric/utilities/lib/FabricPerformance';\r\n\r\n/**\r\n * Takes a collection of collection of styles, defined in various formats, and compresses them into\r\n * a single thing of one format to return.\r\n * If any class names (strings) are passed in, it will return a list of space-separated class names,\r\n * using glamor to generate a class name for all passed in style objects.\r\n * Otherwise, all style objects passed in will be compressed into a single IProcessedStyle.\r\n *\r\n * @export\r\n * @param {(...(IStyle | string)[])} args\r\n * @returns {IStyle}\r\n */\r\nexport function mergeStyles(...args: (IStyle | string | null | undefined)[]): IProcessedStyle | string {\r\n  const classes: string[] = [];\r\n  const rules: Rule[] = [];\r\n\r\n  function _parseArgs(theArgs: (IStyle | string | null | undefined)[]): void {\r\n    for (const arg of theArgs) {\r\n      if (arg) {\r\n        if (typeof arg === 'string') {\r\n          classes.push(arg);\r\n        } else if (Array.isArray(arg)) {\r\n          _parseArgs(arg);\r\n        } else {\r\n          rules.push(arg as Rule);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _parseArgs(args);\r\n\r\n  let rulesObject: IStyle | null = null;\r\n\r\n  if (rules.length) {\r\n    FabricPerformance.measure('glamor.css', () => {\r\n      rulesObject = css(...rules);\r\n    });\r\n  }\r\n\r\n  if (classes.length) {\r\n    if (rulesObject) {\r\n      classes.push((rulesObject as IStyle).toString());\r\n    }\r\n    return classes.join(' ');\r\n  }\r\n\r\n  return rulesObject || {};\r\n}\r\n"]}