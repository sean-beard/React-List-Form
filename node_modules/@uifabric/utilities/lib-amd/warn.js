define(["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _warningCallback = warn;
    /**
     * Warns when a deprecated props are being used.
     *
     * @public
     * @param componentName - The name of the component being used.
     * @param props - The props passed into the component.
     * @param deprecationMap - The map of deprecations, where key is the prop name and the value is
     * either null or a replacement prop name.
     */
    function warnDeprecations(componentName, props, deprecationMap) {
        for (var propName in deprecationMap) {
            if (props && propName in props) {
                var deprecationMessage = componentName + " property '" + propName + "' was used but has been deprecated.";
                var replacementPropName = deprecationMap[propName];
                if (replacementPropName) {
                    deprecationMessage += " Use '" + replacementPropName + "' instead.";
                }
                _warningCallback(deprecationMessage);
            }
        }
    }
    exports.warnDeprecations = warnDeprecations;
    /**
     * Warns when two props which are mutually exclusive are both being used.
     *
     * @public
     * @param componentName - The name of the component being used.
     * @param props - The props passed into the component.
     * @param exclusiveMap - A map where the key is a parameter, and the value is the other parameter.
     */
    function warnMutuallyExclusive(componentName, props, exclusiveMap) {
        for (var propName in exclusiveMap) {
            if (props && propName in props) {
                var propInExclusiveMapValue = exclusiveMap[propName];
                if (propInExclusiveMapValue && propInExclusiveMapValue in props) {
                    _warningCallback(componentName + " property '" + propName + "' is mutually exclusive with '" + exclusiveMap[propName] + "'. Use one or the other.");
                }
            }
        }
    }
    exports.warnMutuallyExclusive = warnMutuallyExclusive;
    /**
     * Warns when props are required if a condition is met.
     *
     * @public
     * @param componentName - The name of the component being used.
     * @param props - The props passed into the component.
     * @param requiredProps - The name of the props that are required when the condition is met.
     * @param conditionalPropName - The name of the prop that the condition is based on.
     * @param condition - Whether the condition is met.
    */
    function warnConditionallyRequiredProps(componentName, props, requiredProps, conditionalPropName, condition) {
        if (condition === true) {
            for (var _i = 0, requiredProps_1 = requiredProps; _i < requiredProps_1.length; _i++) {
                var requiredPropName = requiredProps_1[_i];
                if (!(requiredPropName in props)) {
                    _warningCallback(componentName + " property '" + requiredPropName + "' is required when '" + conditionalPropName + "' is used.'");
                }
            }
        }
    }
    exports.warnConditionallyRequiredProps = warnConditionallyRequiredProps;
    /**
     * Sends a warning to console, if the api is present.
     *
     * @public
     * @param message - Warning message.
     */
    function warn(message) {
        if (console && console.warn) {
            console.warn(message);
        }
    }
    exports.warn = warn;
    /**
     * Configures the warning callback. Passing in undefined will reset it to use the default
     * console.warn function.
     *
     * @public
     * @param warningCallback - Callback to override the generated warnings.
     */
    function setWarningCallback(warningCallback) {
        _warningCallback = warningCallback === undefined ? warn : warningCallback;
    }
    exports.setWarningCallback = setWarningCallback;
});
//# sourceMappingURL=warn.js.map