/* tslint:disable:no-string-literal */
define(["require", "exports", "./dom"], function (require, exports, dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';
    var IS_VISIBLE_ATTRIBUTE = 'data-is-visible';
    var FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';
    var FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';
    /**
     * Gets the first focusable element.
     *
     * @public
     */
    function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
        return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);
    }
    exports.getFirstFocusable = getFirstFocusable;
    /**
     * Gets the last focusable element.
     *
     * @public
     */
    function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
        return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);
    }
    exports.getLastFocusable = getLastFocusable;
    /**
     * Attempts to focus the first focusable element that is a child or child's child of the rootElement.
     *
     * @public
     * @param rootElement - Element to start the search for a focusable child.
     * @returns True if focus was set, false if it was not.
     */
    function focusFirstChild(rootElement) {
        var element = getNextElement(rootElement, rootElement, true, false, false, true);
        if (element) {
            element.focus();
            return true;
        }
        return false;
    }
    exports.focusFirstChild = focusFirstChild;
    /**
     * Traverse to find the previous element.
     *
     * @public
     */
    function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot) {
        if (!currentElement ||
            (!allowFocusRoot && currentElement === rootElement)) {
            return null;
        }
        var isCurrentElementVisible = isElementVisible(currentElement);
        // Check its children.
        if (traverseChildren && isCurrentElementVisible &&
            (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
            var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot);
            if (childMatch) {
                return childMatch;
            }
        }
        // Check the current node, if it's not the first traversal.
        if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
            return currentElement;
        }
        // Check its previous sibling.
        var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot);
        if (siblingMatch) {
            return siblingMatch;
        }
        // Check its parent.
        if (!suppressParentTraversal) {
            return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot);
        }
        return null;
    }
    exports.getPreviousElement = getPreviousElement;
    /**
     * Traverse to find the next focusable element.
     *
     * @public
     */
    function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot) {
        if (!currentElement ||
            (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {
            return null;
        }
        var isCurrentElementVisible = isElementVisible(currentElement);
        // Check the current node, if it's not the first traversal.
        if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
            return currentElement;
        }
        // Check its children.
        if (!suppressChildTraversal && isCurrentElementVisible &&
            (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
            var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot);
            if (childMatch) {
                return childMatch;
            }
        }
        if (currentElement === rootElement) {
            return null;
        }
        // Check its sibling.
        var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot);
        if (siblingMatch) {
            return siblingMatch;
        }
        if (!suppressParentTraversal) {
            return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot);
        }
        return null;
    }
    exports.getNextElement = getNextElement;
    /**
     * Determines if an element is visible.
     *
     * @public
     */
    function isElementVisible(element) {
        // If the element is not valid, return false.
        if (!element || !element.getAttribute) {
            return false;
        }
        var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);
        // If the element is explicitly marked with the visibility attribute, return that value as boolean.
        if (visibilityAttribute !== null && visibilityAttribute !== undefined) {
            return visibilityAttribute === 'true';
        }
        // Fallback to other methods of determining actual visibility.
        return (element.offsetHeight !== 0 ||
            element.offsetParent !== null ||
            element.isVisible === true); // used as a workaround for testing.
    }
    exports.isElementVisible = isElementVisible;
    /**
     * Determines if an element can receive focus.
     *
     * @public
     */
    function isElementTabbable(element) {
        // If this element is null or is disabled, it is not considered tabbable.
        if (!element || element.disabled) {
            return false;
        }
        var tabIndex = 0;
        var tabIndexAttributeValue = null;
        if (element && element.getAttribute) {
            tabIndexAttributeValue = element.getAttribute('tabIndex');
            if (tabIndexAttributeValue) {
                tabIndex = parseInt(tabIndexAttributeValue, 10);
            }
        }
        var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;
        var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;
        return (!!element &&
            isFocusableAttribute !== 'false' &&
            (element.tagName === 'A' ||
                (element.tagName === 'BUTTON') ||
                (element.tagName === 'INPUT') ||
                (element.tagName === 'TEXTAREA') ||
                isFocusableAttribute === 'true' ||
                isTabIndexSet ||
                element.getAttribute && element.getAttribute('role') === 'button'));
    }
    exports.isElementTabbable = isElementTabbable;
    /**
     * Determines if a given element is a focus zone.
     *
     * @public
     */
    function isElementFocusZone(element) {
        return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));
    }
    exports.isElementFocusZone = isElementFocusZone;
    /**
     * Determines if a given element is a focus sub zone.
     *
     * @public
     */
    function isElementFocusSubZone(element) {
        return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');
    }
    exports.isElementFocusSubZone = isElementFocusSubZone;
    /**
     * Determines if an element, or any of its children, contain focus.
     *
     * @public
     */
    function doesElementContainFocus(element) {
        var document = dom_1.getDocument(element);
        var currentActiveElement = document && document.activeElement;
        if (currentActiveElement && dom_1.elementContains(element, currentActiveElement)) {
            return true;
        }
        return false;
    }
    exports.doesElementContainFocus = doesElementContainFocus;
});
//# sourceMappingURL=focus.js.map