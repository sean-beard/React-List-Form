{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.umd.min.js","webpack:///webpack/bootstrap 55a133070338ee6fbed4","webpack:///./src/webpack-entry.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","mainExport","default","key","hasOwnProperty","convert","object","Object","keys","reduce","newObj","originalKey","originalValue","isString","trim","_convertProperty","convertProperty","value","isNoFlip","test","getPropertyDoppelganger","getValueDoppelganger","property","propertiesToConvert","isObject","isNum","isNumber","importantlessValue","replace","isImportant","length","valueConverter","propertyValueConverters","newValue","valuesToConvert","getValuesAsList","split","map","i","filter","Boolean","_ref","item","list","state","openParansCount","match","closedParansCount","parensDepth","push","handleQuartetValues","splitValues","_splitValues2","_slicedToArray","top","right","bottom","left","join","calculateNewBackgroundPosition","idx","indexOf","parseFloat","len","toFixed","arrayToObject","array","obj","_ref2","_ref3","prop1","prop2","val","_typeof","includes","inclusive","inclusee","defineProperty","Symbol","iterator","constructor","prototype","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","Array","isArray","TypeError","padding","textShadow","negative","number","doubleNegative","borderColor","borderRadius","_value$split","_value$split2","radius1","radius2","convertedRadius1","convertedRadius2","reverse","_splitValues","topLeft","topRight","bottomRight","bottomLeft","background","backgroundPositionValue","backgroundPosition","backgroundImage","g1","group2","group","backgroundPositionX","margin","borderWidth","boxShadow","webkitBoxShadow","mozBoxShadow","borderStyle"],"mappings":"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","file":"index.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rtlCSSJS\"] = factory();\n\telse\n\t\troot[\"rtlCSSJS\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rtlCSSJS\"] = factory();\n\telse\n\t\troot[\"rtlCSSJS\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar mainExport = __webpack_require__(1);\n\t\n\tmodule.exports = mainExport.default;\n\tfor (var key in mainExport) {\n\t  if (mainExport.hasOwnProperty(key)) {\n\t    module.exports[key] = mainExport[key];\n\t  }\n\t}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\t// this will be an object of properties that map to their corresponding rtl property (their doppelganger)\n\tvar propertiesToConvert = arrayToObject([['paddingLeft', 'paddingRight'], ['marginLeft', 'marginRight'], ['left', 'right'], ['borderLeft', 'borderRight'], ['borderLeftColor', 'borderRightColor'], ['borderLeftStyle', 'borderRightStyle'], ['borderTopLeftRadius', 'borderTopRightRadius'], ['borderBottomLeftRadius', 'borderBottomRightRadius']]);\n\t\n\t// this is the same as the propertiesToConvert except for values\n\tvar valuesToConvert = arrayToObject([['ltr', 'rtl'], ['left', 'right'], ['w-resize', 'e-resize'], ['sw-resize', 'se-resize'], ['nw-resize', 'ne-resize']]);\n\t\n\t// some values require a little fudging, that fudging goes here.\n\tvar propertyValueConverters = {\n\t  padding: function padding(value) {\n\t    if (isNumber(value)) {\n\t      return value;\n\t    }\n\t    return handleQuartetValues(value);\n\t  },\n\t  textShadow: function textShadow(value) {\n\t    // intentionally leaving off the `g` flag here because we only want to change the first number (which is the offset-x)\n\t    return value.replace(/(-*)([.|\\d]+)/, function (match, negative, number) {\n\t      if (number === '0') {\n\t        return match;\n\t      }\n\t      var doubleNegative = negative === '' ? '-' : '';\n\t      return '' + doubleNegative + number;\n\t    });\n\t  },\n\t  borderColor: function borderColor(value) {\n\t    return handleQuartetValues(value);\n\t  },\n\t  borderRadius: function borderRadius(value) {\n\t    if (isNumber(value)) {\n\t      return value;\n\t    }\n\t    if (includes(value, '/')) {\n\t      var _value$split = value.split('/'),\n\t          _value$split2 = _slicedToArray(_value$split, 2),\n\t          radius1 = _value$split2[0],\n\t          radius2 = _value$split2[1];\n\t\n\t      var convertedRadius1 = propertyValueConverters.borderRadius(radius1.trim());\n\t      var convertedRadius2 = propertyValueConverters.borderRadius(radius2.trim());\n\t      return convertedRadius1 + ' / ' + convertedRadius2;\n\t    }\n\t    var splitValues = getValuesAsList(value);\n\t    switch (splitValues.length) {\n\t      case 2:\n\t        {\n\t          return splitValues.reverse().join(' ');\n\t        }\n\t      case 4:\n\t        {\n\t          var _splitValues = _slicedToArray(splitValues, 4),\n\t              topLeft = _splitValues[0],\n\t              topRight = _splitValues[1],\n\t              bottomRight = _splitValues[2],\n\t              bottomLeft = _splitValues[3];\n\t\n\t          return [topRight, topLeft, bottomLeft, bottomRight].join(' ');\n\t        }\n\t      default:\n\t        {\n\t          return value;\n\t        }\n\t    }\n\t  },\n\t  background: function background(value) {\n\t    // Yeah, this is in need of a refactor 🙃...\n\t    // but this property is a tough cookie 🍪\n\t    // get the backgroundPosition out of the string by removing everything that couldn't be the backgroundPosition value\n\t    var backgroundPositionValue = value.replace(/(url\\(.*?\\))|(rgba?\\(.*?\\))|(hsl\\(.*?\\))|(#[a-fA-F0-9]+)|((^| )(\\D)+( |$))/g, '').trim();\n\t    // replace that backgroundPosition value with the converted version\n\t    value = value.replace(backgroundPositionValue, propertyValueConverters.backgroundPosition(backgroundPositionValue));\n\t    // do the backgroundImage value replacing on the whole value (because why not?)\n\t    return propertyValueConverters.backgroundImage(value);\n\t  },\n\t  backgroundImage: function backgroundImage(value) {\n\t    if (!includes(value, 'url(')) {\n\t      return value;\n\t    }\n\t    // sorry for the regex 😞, but basically this replaces _every_ instance of `ltr`, `rtl`, `right`, and `left` with\n\t    // the corresponding opposite. A situation we're accepting here:\n\t    // url('/left/right/rtl/ltr.png') will be changed to url('/right/left/ltr/rtl.png')\n\t    // Definite trade-offs here, but I think it's a good call.\n\t    return value.replace(/(^|\\W|_)((ltr)|(rtl)|(left)|(right))(\\W|_|$)/g, function (match, g1, group2) {\n\t      return match.replace(group2, valuesToConvert[group2]);\n\t    });\n\t  },\n\t  backgroundPosition: function backgroundPosition(value) {\n\t    return value\n\t    // intentionally only grabbing the first instance of this because that represents `left`\n\t    .replace(/^((-|\\d|\\.)+%)/, function (match, group) {\n\t      return calculateNewBackgroundPosition(group);\n\t    }).replace(/(left)|(right)/, function (match) {\n\t      return valuesToConvert[match];\n\t    });\n\t  },\n\t  backgroundPositionX: function backgroundPositionX(value) {\n\t    if (isNumber(value)) {\n\t      return value;\n\t    }\n\t    return propertyValueConverters.backgroundPosition(value);\n\t  }\n\t};\n\tpropertyValueConverters.margin = propertyValueConverters.padding;\n\tpropertyValueConverters.borderWidth = propertyValueConverters.padding;\n\tpropertyValueConverters.boxShadow = propertyValueConverters.textShadow;\n\tpropertyValueConverters.webkitBoxShadow = propertyValueConverters.textShadow;\n\tpropertyValueConverters.mozBoxShadow = propertyValueConverters.textShadow;\n\tpropertyValueConverters.borderStyle = propertyValueConverters.borderColor;\n\t\n\t// here's our main export! 👋\n\texports.default = convert;\n\t\n\t/**\n\t * converts properties and values in the CSS in JS object to their corresponding RTL values\n\t * @param {Object} object the CSS in JS object\n\t * @return {Object} the RTL converted object\n\t */\n\t\n\tfunction convert(object) {\n\t  return Object.keys(object).reduce(function (newObj, originalKey) {\n\t    var originalValue = object[originalKey];\n\t    if (isString(originalValue)) {\n\t      // you're welcome to later code 😺\n\t      originalValue = originalValue.trim();\n\t    }\n\t\n\t    var _convertProperty = convertProperty(originalKey, originalValue),\n\t        key = _convertProperty.key,\n\t        value = _convertProperty.value;\n\t\n\t    newObj[key] = value;\n\t    return newObj;\n\t  }, {});\n\t}\n\t\n\t/**\n\t * Converts a property and its value to the corresponding RTL key and value\n\t * @param {String} originalKey the original property key\n\t * @param {Number|String|Object} originalValue the original css property value\n\t * @return {Object} the new {key, value} pair\n\t */\n\tfunction convertProperty(originalKey, originalValue) {\n\t  var isNoFlip = /\\/\\*\\s?@noflip\\s?\\*\\//.test(originalValue);\n\t  var key = isNoFlip ? originalKey : getPropertyDoppelganger(originalKey);\n\t  var value = isNoFlip ? originalValue : getValueDoppelganger(key, originalValue);\n\t  return { key: key, value: value };\n\t}\n\t\n\t/**\n\t * This gets the RTL version of the given property if it has a corresponding RTL property\n\t * @param {String} property the name of the property\n\t * @return {String} the name of the RTL property\n\t */\n\tfunction getPropertyDoppelganger(property) {\n\t  return propertiesToConvert[property] || property;\n\t}\n\t\n\t/**\n\t * This converts the given value to the RTL version of that value based on the key\n\t * @param {String} key this is the key (note: this should be the RTL version of the originalKey)\n\t * @param {String|Number|Object} originalValue the original css property value. If it's an object, then we'll convert that as well\n\t * @return {String|Number|Object} the converted value\n\t */\n\tfunction getValueDoppelganger(key, originalValue) {\n\t  /* eslint complexity:[2, 8] */ // let's try to keep the complexity down... If we have to do this much more, let's break this up\n\t  if (originalValue === null || typeof originalValue === 'undefined') {\n\t    return originalValue;\n\t  }\n\t\n\t  if (isObject(originalValue)) {\n\t    return convert(originalValue); // recurssion 🌀\n\t  }\n\t  var isNum = isNumber(originalValue);\n\t  var importantlessValue = isNum ? originalValue : originalValue.replace(/ !important.*?$/, '');\n\t  var isImportant = !isNum && importantlessValue.length !== originalValue.length;\n\t  var valueConverter = propertyValueConverters[key];\n\t  var newValue = void 0;\n\t  if (valueConverter) {\n\t    newValue = valueConverter(importantlessValue);\n\t  } else {\n\t    newValue = valuesToConvert[importantlessValue] || importantlessValue;\n\t  }\n\t  if (isImportant) {\n\t    return newValue + ' !important';\n\t  }\n\t  return newValue;\n\t}\n\t\n\t/**\n\t * This takes a list of CSS values and converts it to an array\n\t * @param {String} value - something like `1px`, `1px 2em`, or `3pt rgb(150, 230, 550) 40px calc(100% - 5px)`\n\t * @return {Array} the split values (for example: `['3pt', 'rgb(150, 230, 550)', '40px', 'calc(100% - 5px)']`)\n\t */\n\tfunction getValuesAsList(value) {\n\t  return value.replace(/ +/g, ' ') // remove all extraneous spaces\n\t  .split(' ').map(function (i) {\n\t    return i.trim();\n\t  }) // get rid of extra space before/after each item\n\t  .filter(Boolean) // get rid of empty strings\n\t  // join items which are within parenthese\n\t  // luckily `calc (100% - 5px)` is invalid syntax and it must be `calc(100% - 5px)`, otherwise this would be even more complex\n\t  .reduce(function (_ref, item) {\n\t    var list = _ref.list,\n\t        state = _ref.state;\n\t\n\t    var openParansCount = (item.match(/\\(/g) || []).length;\n\t    var closedParansCount = (item.match(/\\)/g) || []).length;\n\t    if (state.parensDepth > 0) {\n\t      list[list.length - 1] = list[list.length - 1] + ' ' + item;\n\t    } else {\n\t      list.push(item);\n\t    }\n\t    state.parensDepth += openParansCount - closedParansCount;\n\t    return { list: list, state: state };\n\t  }, { list: [], state: { parensDepth: 0 } }).list;\n\t}\n\t\n\t/**\n\t * This is intended for properties that are `top right bottom left` and will switch them to `top left bottom right`\n\t * @param {String} value - `1px 2px 3px 4px` for example, but also handles cases where there are too few/too many and\n\t * simply returns the value in those cases (which is the correct behavior)\n\t * @return {String} the result - `1px 4px 3px 2px` for example.\n\t */\n\tfunction handleQuartetValues(value) {\n\t  var splitValues = getValuesAsList(value);\n\t  if (splitValues.length <= 3 || splitValues.length > 4) {\n\t    return value;\n\t  }\n\t\n\t  var _splitValues2 = _slicedToArray(splitValues, 4),\n\t      top = _splitValues2[0],\n\t      right = _splitValues2[1],\n\t      bottom = _splitValues2[2],\n\t      left = _splitValues2[3];\n\t\n\t  return [top, left, bottom, right].join(' ');\n\t}\n\t\n\t/**\n\t * Takes a percentage for background position and inverts it.\n\t * This was copied and modified from CSSJanus:\n\t * https://github.com/cssjanus/cssjanus/blob/4245f834365f6cfb0239191a151432fb85abab23/src/cssjanus.js#L152-L175\n\t * @param {String} value - the original value (for example 77%)\n\t * @return {String} the result (for example 23%)\n\t */\n\tfunction calculateNewBackgroundPosition(value) {\n\t  var idx = value.indexOf('.');\n\t  if (idx === -1) {\n\t    value = 100 - parseFloat(value) + '%';\n\t  } else {\n\t    // Two off, one for the \"%\" at the end, one for the dot itself\n\t    var len = value.length - idx - 2;\n\t    value = 100 - parseFloat(value);\n\t    value = value.toFixed(len) + '%';\n\t  }\n\t  return value;\n\t}\n\t\n\t/**\n\t * Takes an array of [keyValue1, keyValue2] pairs and creates an object of {keyValue1: keyValue2, keyValue2: keyValue1}\n\t * @param {Array} array the array of pairs\n\t * @return {Object} the {key, value} pair object\n\t */\n\tfunction arrayToObject(array) {\n\t  return array.reduce(function (obj, _ref2) {\n\t    var _ref3 = _slicedToArray(_ref2, 2),\n\t        prop1 = _ref3[0],\n\t        prop2 = _ref3[1];\n\t\n\t    obj[prop1] = prop2;\n\t    obj[prop2] = prop1;\n\t    return obj;\n\t  }, {});\n\t}\n\t\n\tfunction isNumber(val) {\n\t  return typeof val === 'number';\n\t}\n\t\n\tfunction isObject(val) {\n\t  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';\n\t}\n\t\n\tfunction isString(val) {\n\t  return typeof val === 'string';\n\t}\n\t\n\tfunction includes(inclusive, inclusee) {\n\t  return inclusive.indexOf(inclusee) !== -1;\n\t}\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// index.umd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 55a133070338ee6fbed4","const mainExport = require('./index')\n\nmodule.exports = mainExport.default\nfor (const key in mainExport) {\n  if (mainExport.hasOwnProperty(key)) {\n    module.exports[key] = mainExport[key]\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/webpack-entry.js","// this will be an object of properties that map to their corresponding rtl property (their doppelganger)\nconst propertiesToConvert = arrayToObject([\n  ['paddingLeft', 'paddingRight'],\n  ['marginLeft', 'marginRight'],\n  ['left', 'right'],\n  ['borderLeft', 'borderRight'],\n  ['borderLeftColor', 'borderRightColor'],\n  ['borderLeftStyle', 'borderRightStyle'],\n  ['borderTopLeftRadius', 'borderTopRightRadius'],\n  ['borderBottomLeftRadius', 'borderBottomRightRadius'],\n])\n\n// this is the same as the propertiesToConvert except for values\nconst valuesToConvert = arrayToObject([\n  ['ltr', 'rtl'],\n  ['left', 'right'],\n  ['w-resize', 'e-resize'],\n  ['sw-resize', 'se-resize'],\n  ['nw-resize', 'ne-resize'],\n])\n\n// some values require a little fudging, that fudging goes here.\nconst propertyValueConverters = {\n  padding(value) {\n    if (isNumber(value)) {\n      return value\n    }\n    return handleQuartetValues(value)\n  },\n  textShadow(value) {\n    // intentionally leaving off the `g` flag here because we only want to change the first number (which is the offset-x)\n    return value.replace(/(-*)([.|\\d]+)/, (match, negative, number) => {\n      if (number === '0') {\n        return match\n      }\n      const doubleNegative = negative === '' ? '-' : ''\n      return `${doubleNegative}${number}`\n    })\n  },\n  borderColor(value) {\n    return handleQuartetValues(value)\n  },\n  borderRadius(value) {\n    if (isNumber(value)) {\n      return value\n    }\n    if (includes(value, '/')) {\n      const [radius1, radius2] = value.split('/')\n      const convertedRadius1 = propertyValueConverters.borderRadius(radius1.trim())\n      const convertedRadius2 = propertyValueConverters.borderRadius(radius2.trim())\n      return `${convertedRadius1} / ${convertedRadius2}`\n    }\n    const splitValues = getValuesAsList(value)\n    switch (splitValues.length) {\n      case 2: {\n        return splitValues.reverse().join(' ')\n      }\n      case 4: {\n        const [topLeft, topRight, bottomRight, bottomLeft] = splitValues\n        return [topRight, topLeft, bottomLeft, bottomRight].join(' ')\n      }\n      default: {\n        return value\n      }\n    }\n  },\n  background(value) {\n    // Yeah, this is in need of a refactor 🙃...\n    // but this property is a tough cookie 🍪\n    // get the backgroundPosition out of the string by removing everything that couldn't be the backgroundPosition value\n    const backgroundPositionValue = value\n      .replace(/(url\\(.*?\\))|(rgba?\\(.*?\\))|(hsl\\(.*?\\))|(#[a-fA-F0-9]+)|((^| )(\\D)+( |$))/g, '').trim()\n    // replace that backgroundPosition value with the converted version\n    value = value\n      .replace(backgroundPositionValue, propertyValueConverters.backgroundPosition(backgroundPositionValue))\n    // do the backgroundImage value replacing on the whole value (because why not?)\n    return propertyValueConverters.backgroundImage(value)\n  },\n  backgroundImage(value) {\n    if (!includes(value, 'url(')) {\n      return value\n    }\n    // sorry for the regex 😞, but basically this replaces _every_ instance of `ltr`, `rtl`, `right`, and `left` with\n    // the corresponding opposite. A situation we're accepting here:\n    // url('/left/right/rtl/ltr.png') will be changed to url('/right/left/ltr/rtl.png')\n    // Definite trade-offs here, but I think it's a good call.\n    return value.replace(/(^|\\W|_)((ltr)|(rtl)|(left)|(right))(\\W|_|$)/g, (match, g1, group2) => {\n      return match.replace(group2, valuesToConvert[group2])\n    })\n  },\n  backgroundPosition(value) {\n    return value\n      // intentionally only grabbing the first instance of this because that represents `left`\n      .replace(/^((-|\\d|\\.)+%)/, (match, group) => calculateNewBackgroundPosition(group))\n      .replace(/(left)|(right)/, match => valuesToConvert[match])\n  },\n  backgroundPositionX(value) {\n    if (isNumber(value)) {\n      return value\n    }\n    return propertyValueConverters.backgroundPosition(value)\n  },\n}\npropertyValueConverters.margin = propertyValueConverters.padding\npropertyValueConverters.borderWidth = propertyValueConverters.padding\npropertyValueConverters.boxShadow = propertyValueConverters.textShadow\npropertyValueConverters.webkitBoxShadow = propertyValueConverters.textShadow\npropertyValueConverters.mozBoxShadow = propertyValueConverters.textShadow\npropertyValueConverters.borderStyle = propertyValueConverters.borderColor\n\n// here's our main export! 👋\nexport default convert\n\n/**\n * converts properties and values in the CSS in JS object to their corresponding RTL values\n * @param {Object} object the CSS in JS object\n * @return {Object} the RTL converted object\n */\nfunction convert(object) {\n  return Object.keys(object).reduce((newObj, originalKey) => {\n    let originalValue = object[originalKey]\n    if (isString(originalValue)) {\n      // you're welcome to later code 😺\n      originalValue = originalValue.trim()\n    }\n    const {key, value} = convertProperty(originalKey, originalValue)\n    newObj[key] = value\n    return newObj\n  }, {})\n}\n\n/**\n * Converts a property and its value to the corresponding RTL key and value\n * @param {String} originalKey the original property key\n * @param {Number|String|Object} originalValue the original css property value\n * @return {Object} the new {key, value} pair\n */\nfunction convertProperty(originalKey, originalValue) {\n  const isNoFlip = /\\/\\*\\s?@noflip\\s?\\*\\//.test(originalValue)\n  const key = isNoFlip ? originalKey : getPropertyDoppelganger(originalKey)\n  const value = isNoFlip ? originalValue : getValueDoppelganger(key, originalValue)\n  return {key, value}\n}\n\n/**\n * This gets the RTL version of the given property if it has a corresponding RTL property\n * @param {String} property the name of the property\n * @return {String} the name of the RTL property\n */\nfunction getPropertyDoppelganger(property) {\n  return propertiesToConvert[property] || property\n}\n\n/**\n * This converts the given value to the RTL version of that value based on the key\n * @param {String} key this is the key (note: this should be the RTL version of the originalKey)\n * @param {String|Number|Object} originalValue the original css property value. If it's an object, then we'll convert that as well\n * @return {String|Number|Object} the converted value\n */\nfunction getValueDoppelganger(key, originalValue) {\n  /* eslint complexity:[2, 8] */ // let's try to keep the complexity down... If we have to do this much more, let's break this up\n  if (originalValue === null || typeof originalValue === 'undefined') {\n    return originalValue\n  }\n\n  if (isObject(originalValue)) {\n    return convert(originalValue) // recurssion 🌀\n  }\n  const isNum = isNumber(originalValue)\n  const importantlessValue = isNum ? originalValue : originalValue.replace(/ !important.*?$/, '')\n  const isImportant = !isNum && importantlessValue.length !== originalValue.length\n  const valueConverter = propertyValueConverters[key]\n  let newValue\n  if (valueConverter) {\n    newValue = valueConverter(importantlessValue)\n  } else {\n    newValue = valuesToConvert[importantlessValue] || importantlessValue\n  }\n  if (isImportant) {\n    return `${newValue} !important`\n  }\n  return newValue\n}\n\n/**\n * This takes a list of CSS values and converts it to an array\n * @param {String} value - something like `1px`, `1px 2em`, or `3pt rgb(150, 230, 550) 40px calc(100% - 5px)`\n * @return {Array} the split values (for example: `['3pt', 'rgb(150, 230, 550)', '40px', 'calc(100% - 5px)']`)\n */\nfunction getValuesAsList(value) {\n  return value\n    .replace(/ +/g, ' ') // remove all extraneous spaces\n    .split(' ')\n    .map(i => i.trim()) // get rid of extra space before/after each item\n    .filter(Boolean) // get rid of empty strings\n     // join items which are within parenthese\n     // luckily `calc (100% - 5px)` is invalid syntax and it must be `calc(100% - 5px)`, otherwise this would be even more complex\n    .reduce(({list, state}, item) => {\n      const openParansCount = (item.match(/\\(/g) || []).length\n      const closedParansCount = (item.match(/\\)/g) || []).length\n      if (state.parensDepth > 0) {\n        list[list.length - 1] = `${list[list.length - 1]} ${item}`\n      } else {\n        list.push(item)\n      }\n      state.parensDepth += openParansCount - closedParansCount\n      return {list, state}\n    }, {list: [], state: {parensDepth: 0}}).list\n}\n\n/**\n * This is intended for properties that are `top right bottom left` and will switch them to `top left bottom right`\n * @param {String} value - `1px 2px 3px 4px` for example, but also handles cases where there are too few/too many and\n * simply returns the value in those cases (which is the correct behavior)\n * @return {String} the result - `1px 4px 3px 2px` for example.\n */\nfunction handleQuartetValues(value) {\n  const splitValues = getValuesAsList(value)\n  if (splitValues.length <= 3 || splitValues.length > 4) {\n    return value\n  }\n  const [top, right, bottom, left] = splitValues\n  return [top, left, bottom, right].join(' ')\n}\n\n/**\n * Takes a percentage for background position and inverts it.\n * This was copied and modified from CSSJanus:\n * https://github.com/cssjanus/cssjanus/blob/4245f834365f6cfb0239191a151432fb85abab23/src/cssjanus.js#L152-L175\n * @param {String} value - the original value (for example 77%)\n * @return {String} the result (for example 23%)\n */\nfunction calculateNewBackgroundPosition(value) {\n  const idx = value.indexOf('.')\n  if (idx === -1) {\n    value = `${100 - parseFloat(value)}%`\n  } else {\n    // Two off, one for the \"%\" at the end, one for the dot itself\n    const len = value.length - idx - 2\n    value = 100 - parseFloat(value)\n    value = `${value.toFixed(len)}%`\n  }\n  return value\n}\n\n/**\n * Takes an array of [keyValue1, keyValue2] pairs and creates an object of {keyValue1: keyValue2, keyValue2: keyValue1}\n * @param {Array} array the array of pairs\n * @return {Object} the {key, value} pair object\n */\nfunction arrayToObject(array) {\n  return array.reduce((obj, [prop1, prop2]) => {\n    obj[prop1] = prop2\n    obj[prop2] = prop1\n    return obj\n  }, {})\n}\n\nfunction isNumber(val) {\n  return typeof val === 'number'\n}\n\nfunction isObject(val) {\n  return val && typeof val === 'object'\n}\n\nfunction isString(val) {\n  return typeof val === 'string'\n}\n\nfunction includes(inclusive, inclusee) {\n  return inclusive.indexOf(inclusee) !== -1\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}