{"version":3,"sources":["components/ComboBox/ComboBox.tsx"],"names":[],"mappings":";;;IA6DA,IAAK,eAIJ;IAJD,WAAK,eAAe;QAClB,8DAAa,CAAA;QACb,qDAAQ,CAAA;QACR,2DAAW,CAAA;IACb,CAAC,EAJI,eAAe,KAAf,eAAe,QAInB;IAGD;QAA8B,oCAA6C;QA8CzE,kBAAY,KAAqB;YAAjC,YACE,kBAAM,KAAK,CAAC,SAwBb;YA1CD,iDAAiD;YACjD,mEAAmE;YAClD,yCAAmC,GAAW,IAAI,CAAC,QAAQ,CAAC;YAkB3E,KAAI,CAAC,sBAAsB,CAAC;gBAC1B,oBAAoB,EAAE,aAAa;gBACnC,OAAO,EAAE,oBAAoB;gBAC7B,aAAa,EAAE,OAAO;aACvB,CAAC,CAAC;YAEH,KAAI,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,IAAI,iBAAK,CAAC,UAAU,CAAC,CAAC;YAEzC,IAAI,WAAW,GAAG,KAAK,CAAC,kBAAkB,KAAK,SAAS,GAAG,KAAK,CAAC,kBAAkB,GAAG,KAAK,CAAC,WAAW,CAAC;YACxG,KAAI,CAAC,wCAAwC,GAAG,CAAC,CAAC,CAAC;YAEnD,IAAI,KAAK,GAAW,KAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YAEvE,KAAI,CAAC,KAAK,GAAG;gBACX,MAAM,EAAE,KAAK;gBACb,aAAa,EAAE,KAAK;gBACpB,OAAO,EAAE,KAAK;gBACd,qBAAqB,EAAE,EAAE;gBACzB,cAAc,EAAE,KAAI,CAAC,KAAK,CAAC,OAAO;gBAClC,6BAA6B,EAAE,CAAC,CAAC;gBACjC,mBAAmB,EAAE,EAAE;aACxB,CAAC;;QACJ,CAAC;QAEM,oCAAiB,GAAxB;YACE,mDAAmD;YACnD,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,EAAE,OAAO,EAAE,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;QAChF,CAAC;QAEM,4CAAyB,GAAhC,UAAiC,QAAwB;YACvD,wEAAwE;YACxE,+FAA+F;YAC/F,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,WAAW,IAAI,QAAQ,CAAC,KAAK,CAAC;gBAC1C,CAAC,QAAQ,CAAC,WAAW,KAAK,IAAI,CAAC,KAAK,CAAC,WAAW,IAAI,QAAQ,CAAC,OAAO,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAC/F,IAAI,KAAK,GAAW,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,WAAW,CAAC,CAAC;gBACnF,IAAI,CAAC,QAAQ,CAAC;oBACZ,aAAa,EAAE,KAAK;oBACpB,cAAc,EAAE,QAAQ,CAAC,OAAO;iBACjC,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAEM,qCAAkB,GAAzB,UAA0B,SAAyB,EAAE,SAAyB;YACxE,IAAA,eAGU,EAFZ,gCAAa,EACb,gBAAK,CACQ;YACX,IAAA,eAKU,EAJZ,kBAAM,EACN,oBAAO,EACP,gCAAa,EACb,gEAA6B,CAChB;YAEf,wEAAwE;YACxE,wEAAwE;YACxE,EAAE,CAAC,CAAC,MAAM;gBACR,CAAC,CAAC,SAAS,CAAC,MAAM;oBAChB,SAAS,CAAC,6BAA6B,KAAK,6BAA6B,CAAC,CAAC,CAAC,CAAC;gBAC/E,IAAI,CAAC,eAAe,EAAE,CAAC;YACzB,CAAC;YAED,kEAAkE;YAClE,yBAAyB;YACzB,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,OAAO,IAAI,QAAQ,CAAC,aAAa,KAAK,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;gBAClF,IAAI,CAAC,KAAK,EAAE,CAAC;YACf,CAAC;YAED,uCAAuC;YACvC,oDAAoD;YACpD,iEAAiE;YACjE,2BAA2B;YAC3B,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,KAAK,MAAM;gBAC7B,CAAC,CAAC,MAAM,IAAI,SAAS,CAAC,aAAa,KAAK,aAAa,CAAC;gBACtD,CAAC,OAAO,IAAI,CAAC,CAAC,aAAa,IAAI,KAAK,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC7D,IAAI,CAAC,OAAO,EAAE,CAAC;YACjB,CAAC;QACH,CAAC;QAEM,uCAAoB,GAA3B;YACE,iBAAM,oBAAoB,WAAE,CAAC;YAE7B,8DAA8D;YAC9D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC1C,CAAC;QAED,iBAAiB;QACV,yBAAM,GAAb;YACE,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC;YACd,IAAA,eAaU,EAZZ,wBAAS,EACT,gBAAK,EACL,sBAAQ,EACR,wBAAS,EACT,sBAAQ,EACR,8BAAY,EACZ,yBAA2C,EAA3C,gEAA2C,EAC3C,gCAAa,EACb,8BAAY,EACZ,oCAAe,EACf,wBAAoB,EACpB,gBAAK,CACQ;YACX,IAAA,eAAsE,EAApE,kBAAM,EAAE,gCAAa,EAAE,oBAAO,EAAE,gDAAqB,CAAgB;YAC3E,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAEpD,IAAI,QAAQ,GAAG,0BAAc,CAAC,IAAI,CAAC,KAAK,EAAE,yBAAa,CAAC,CAAC;YAEzD,IAAI,eAAe,GAAG,CAAC,YAAY,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC;YAE/E,IAAI,CAAC,WAAW,GAAG,mCAAa,CAC9B,2BAAS,CAAC,KAAM,EAAE,YAAY,CAAC,EAC/B,SAAU,EACV,CAAC,CAAC,MAAM,EACR,CAAC,CAAC,QAAQ,EACV,CAAC,CAAC,QAAQ,EACV,CAAC,CAAC,OAAO,EACT,CAAC,CAAC,aAAa,EACf,CAAC,CAAC,eAAe,CAClB,CAAC;YAEF,MAAM,CAAC,CACL,gDAAS,QAAQ,IAAG,GAAG,EAAC,MAAM,EAAC,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,SAAS;gBACjE,KAAK,IAAI,CACT,oBAAC,aAAK,IAAC,EAAE,EAAG,EAAE,GAAG,QAAQ,EAAG,QAAQ,EAAG,QAAQ,EAAG,OAAO,EAAG,EAAE,EAAG,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,KAAK,IAAK,KAAK,CAAU,CACxH;gBACD,6BACE,GAAG,EAAG,IAAI,CAAC,WAAW,CAAC,kBAAkB,CAAC,EAC1C,EAAE,EAAG,EAAE,GAAG,SAAS,EACnB,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,IAAI;oBAEjC,oBAAC,2BAAY,4BACY,CAAC,QAAQ,EAChC,GAAG,EAAG,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,EACnC,EAAE,EAAG,EAAE,GAAG,QAAQ,EAClB,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAClC,IAAI,EAAC,MAAM,EACX,GAAG,EAAG,aAAa,EACnB,OAAO,EAAG,IAAI,CAAC,OAAO,EACtB,MAAM,EAAG,IAAI,CAAC,OAAO,EACrB,SAAS,EAAG,IAAI,CAAC,eAAe,EAChC,OAAO,EAAG,IAAI,CAAC,aAAa,EAC5B,OAAO,EAAG,aAAa,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,gBAAgB,EAC5D,kBAAkB,EAAG,IAAI,CAAC,cAAc,mBACxB,MAAM,uBACF,CAAC,CAAC,QAAQ,IAAI,YAAY,KAAK,IAAI,CAAC,EACxD,IAAI,EAAC,UAAU,mBACC,CAAC,CAAC,aAAa,IAAI,QAAQ,CAAC,GAAG,IAAI,GAAG,MAAM,CAAC,EAC7D,QAAQ,EAAG,QAAQ,IAAI,CAAC,aAAa,qBACnB,CAAC,KAAK,IAAI,CAAC,EAAE,GAAG,QAAQ,CAAC,CAAC,gBAC/B,CAAC,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,IAAI,SAAS,CAAC,sBAC9B,CAAC,EAAE,GAAG,SAAS,CAAC,2BACX,CAAC,MAAM,IAAK,aAAwB,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,OAAO,GAAG,aAAa,CAAC,GAAG,IAAI,CAAC,mBAC1F,QAAQ,eACZ,CAAC,EAAE,GAAG,OAAO,CAAC,EAC1B,UAAU,EAAG,KAAK,EAClB,mBAAmB,EAAG,IAAI,CAAC,oBAAoB,EAC/C,qBAAqB,EAAG,qBAAqB,EAC7C,6BAA6B,EAAG,IAAI,CAAC,wCAAwC,EAC7E,8CAA8C,EAAG,IAAI,CAAC,yDAAyD,GAAK;oBACtH,oBAAC,mBAAU,IACT,SAAS,EAAG,8BAA8B,EAC1C,MAAM,EAAG,IAAI,CAAC,qBAAqB,EAAE,EACrC,IAAI,EAAC,cAAc,iBACP,MAAM,EAClB,QAAQ,EAAG,CAAC,CAAC,EACb,OAAO,EAAG,IAAI,CAAC,gBAAgB,EAC/B,SAAS,EAAG,eAAe,EAC3B,QAAQ,EAAG,QAAQ,GAAK,CACtB;gBAEJ,MAAM,IAAI,CACT,iBAAyB,sBAAM,IAAI,CAAC,KAAY,GAAI,IAAI,CAAC,kBAAkB,CAAC,CAC9E;gBAEC,YAAY;oBACZ,6BACE,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,YAAY,IACvC,YAAY,CACV,CAEJ,CACP,CAAC;QACJ,CAAC;QAED;;WAEG;QAEI,wBAAK,GAAZ;YACE,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;gBACnB,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;YACzB,CAAC;QACH,CAAC;QAED;;;;;;WAMG;QAEK,2DAAwC,GAAhD;YACE,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC,CAAC,CAAC;gBAC5D,MAAM,CAAC,IAAI,CAAC;YACd,CAAC;YAED,EAAE,CAAC,CAAC,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,oBAAoB,KAAK,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,KAAK,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC;gBACxH,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC;YACnC,CAAC;YAED,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;QAC9B,CAAC;QAED;;;;;;;WAOG;QAEK,4EAAyD,GAAjE;YACE,MAAM,CAAC,IAAI,CAAC,oBAAoB,KAAK,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC;QACxE,CAAC;QAED;;;;WAIG;QAEK,mCAAgB,GAAxB;YACM,IAAA,eAIU,EAHZ,gBAAK,EACL,gCAAa,EACb,8BAAY,CACC;YACX,IAAA,eAOU,EANZ,gCAAa,EACb,gEAA6B,EAC7B,kCAAc,EACd,4CAAmB,EACnB,gDAAqB,EACrB,kBAAM,CACO;YAEf,IAAI,wBAAwB,GAAG,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,6BAA6B,CAAC,CAAC;YAEtG,+CAA+C;YAC/C,4DAA4D;YAC5D,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,wBAAwB,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;gBACnD,MAAM,CAAC,KAAK,CAAC;YACf,CAAC;YAED,IAAI,KAAK,GAAG,aAAa,CAAC;YAE1B,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;gBAElB,4DAA4D;gBAC5D,iEAAiE;gBACjE,6BAA6B;gBAC7B,EAAE,CAAC,CAAC,YAAY,KAAK,IAAI,IAAI,wBAAwB,CAAC,CAAC,CAAC;oBACtD,KAAK,GAAG,6BAA6B,CAAC;gBACxC,CAAC;gBAED,2FAA2F;gBAC3F,gGAAgG;gBAChG,MAAM,CAAC,mBAAmB,KAAK,EAAE,GAAG,mBAAmB;oBACrD,CAAC,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,KAAK,CAAC,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC;YACvF,CAAC;YAAC,IAAI,CAAC,CAAC;gBAEN,6CAA6C;gBAC7C,8CAA8C;gBAC9C,yDAAyD;gBACzD,EAAE,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC;oBAE7B,oCAAoC;oBACpC,wCAAwC;oBACxC,6BAA6B;oBAC7B,EAAE,CAAC,CAAC,YAAY,KAAK,IAAI,CAAC,CAAC,CAAC;wBAC1B,MAAM,CAAC,mBAAmB,CAAC;oBAC7B,CAAC;oBAED,KAAK,GAAG,6BAA6B,CAAC;gBACxC,CAAC;gBAED,sEAAsE;gBACtE,6CAA6C;gBAC7C,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,KAAK,CAAC,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,qBAAqB,CAAC;YAC7G,CAAC;QACH,CAAC;QAED;;;;;WAKG;QACK,qCAAkB,GAA1B,UAA2B,OAAsC,EAAE,KAAa;YAC9E,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACb,MAAM,CAAC,KAAK,CAAC;YACf,CAAC;YACD,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC;QAC9C,CAAC;QAED;;;WAGG;QAEK,iCAAc,GAAtB,UAAuB,YAAoB;YACzC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACxB,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAChD,MAAM,CAAC;YACT,CAAC;YAED,IAAI,CAAC,KAAK,CAAC,aAAa;gBACtB,IAAI,CAAC,+BAA+B,CAAC,YAAY,CAAC;gBAClD,IAAI,CAAC,kCAAkC,CAAC,YAAY,CAAC,CAAC;QAC1D,CAAC;QAED;;;;WAIG;QACK,kDAA+B,GAAvC,UAAwC,YAAoB;YAExD,IAAA,0CAAc,CACD;YAEf,sDAAsD;YACtD,EAAE,CAAC,CAAC,YAAY,KAAK,EAAE,CAAC,CAAC,CAAC;gBACxB,MAAM,CAAC;YACT,CAAC;YAED,wCAAwC;YACxC,0CAA0C;YAC1C,IAAI,oBAAoB,GAAW,YAAY,CAAC;YAChD,YAAY,GAAG,YAAY,CAAC,iBAAiB,EAAE,CAAC;YAEhD,IAAI,wBAAwB,GAAG,EAAE,CAAC;YAClC,IAAI,gCAAgC,GAAG,CAAC,CAAC,CAAC;YAE1C,4EAA4E;YAC5E,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,KAAK,IAAI,CAAC,CAAC,CAAC;gBAErC,2GAA2G;gBAC3G,IAAI,KAAK,GAAG,cAAc,CAAC,GAAG,CAAC,UAAC,IAAI,EAAE,KAAK,IAAO,MAAM,sBAAM,IAAI,IAAE,KAAK,OAAA,IAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,MAAM,IAAK,OAAA,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,EAAnH,CAAmH,CAAC,CAAC,MAAM,CAAC,UAAC,MAAM,IAAK,OAAA,MAAM,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,EAA3D,CAA2D,CAAC,CAAC;gBACxS,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBACrB,mGAAmG;oBACnG,wBAAwB,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,EAAE,KAAK,YAAY,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC;oBAEnG,2CAA2C;oBAC3C,gCAAgC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBACpD,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBAEN,gHAAgH;gBAChH,IAAI,KAAK,GAAG,cAAc,CAAC,GAAG,CAAC,UAAC,IAAI,EAAE,KAAK,IAAO,MAAM,sBAAM,IAAI,IAAE,KAAK,OAAA,IAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,MAAM,IAAK,OAAA,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,EAAnH,CAAmH,CAAC,CAAC,MAAM,CAAC,UAAC,MAAM,IAAK,OAAA,MAAM,CAAC,IAAI,CAAC,iBAAiB,EAAE,KAAK,YAAY,EAAhD,CAAgD,CAAC,CAAC;gBAE7R,yCAAyC;gBACzC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;oBACvB,gCAAgC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBACpD,CAAC;YACH,CAAC;YAED,wBAAwB;YACxB,IAAI,CAAC,eAAe,CAAC,oBAAoB,EAAE,gCAAgC,EAAE,wBAAwB,CAAC,CAAC;QACzG,CAAC;QAED;;;;WAIG;QACK,qDAAkC,GAA1C,UAA2C,YAAoB;YAA/D,iBA0DC;YAzDK,IAAA,eAKU,EAJZ,4CAAmB,EACnB,gEAA6B,EAC7B,kCAAc,EACd,gCAAa,CACA;YAEf,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,KAAK,IAAI,CAAC,CAAC,CAAC;gBAErC,qDAAqD;gBACrD,4EAA4E;gBAC5E,2EAA2E;gBAC3E,wFAAwF;gBACxF,6DAA6D;gBAC7D,EAAE,CAAC,CAAC,YAAY,KAAK,EAAE,CAAC,CAAC,CAAC;oBAExB,mDAAmD;oBACnD,4DAA4D;oBAC5D,+DAA+D;oBAC/D,iEAAiE;oBACjE,EAAE,CAAC,CAAC,IAAI,CAAC,wCAAwC,GAAG,CAAC,CAAC,CAAC,CAAC;wBACtD,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,wCAAwC,CAAC,CAAC;wBACxE,IAAI,CAAC,wCAAwC,GAAG,CAAC,CAAC,CAAC;wBACnD,YAAY,GAAG,mBAAmB,GAAG,YAAY,CAAC;oBACpD,CAAC;oBAED,IAAI,oBAAoB,GAAW,YAAY,CAAC;oBAChD,YAAY,GAAG,YAAY,CAAC,iBAAiB,EAAE,CAAC;oBAEhD,2GAA2G;oBAC3G,IAAI,KAAK,GAAG,cAAc,CAAC,GAAG,CAAC,UAAC,IAAI,EAAE,CAAC,IAAO,MAAM,sBAAM,IAAI,IAAE,KAAK,EAAE,CAAC,IAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,MAAM,IAAK,OAAA,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,EAAnH,CAAmH,CAAC,CAAC,MAAM,CAAC,UAAC,MAAM,IAAK,OAAA,MAAM,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,EAA3D,CAA2D,CAAC,CAAC;oBAEvS,yCAAyC;oBACzC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;wBACrB,IAAI,CAAC,eAAe,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;oBAC5E,CAAC;oBAED,uEAAuE;oBACvE,IAAI,CAAC,wCAAwC;wBAC3C,IAAI,CAAC,MAAM,CAAC,UAAU,CACpB,cAAQ,KAAI,CAAC,wCAAwC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAC7D,IAAI,CAAC,mCAAmC,CACzC,CAAC;oBACJ,MAAM,CAAC;gBACT,CAAC;YACH,CAAC;YAED,6FAA6F;YAC7F,kGAAkG;YAClG,4CAA4C;YAC5C,IAAI,KAAK,GAAG,6BAA6B,IAAI,CAAC,GAAG,6BAA6B,GAAG,aAAa,CAAC;YAE/F,iDAAiD;YACjD,kDAAkD;YAClD,oDAAoD;YACpD,6DAA6D;YAC7D,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;QACvC,CAAC;QAED;;;;;;;WAOG;QACK,0CAAuB,GAA/B,UAAgC,KAAa,EAAE,eAAgC;YACvE,IAAA,0CAAc,CAAgB;YAEpC,IAAI,QAAQ,GAAG,KAAK,GAAG,eAAe,CAAC;YAEvC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;YAEtE,IAAI,MAAM,GAAoB,cAAc,CAAC,QAAQ,CAAC,CAAC;YAEvD,uCAAuC;YACvC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM;gBAC1D,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAE5D,qDAAqD;gBACrD,EAAE,CAAC,CAAC,eAAe,KAAK,eAAe,CAAC,IAAI;oBAC1C,CAAC,CAAC,QAAQ,KAAK,CAAC,IAAI,eAAe,GAAG,eAAe,CAAC,IAAI,CAAC;wBACzD,CAAC,QAAQ,KAAK,cAAc,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxF,QAAQ,GAAG,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC;gBACrE,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,2EAA2E;oBAC3E,MAAM,CAAC,KAAK,CAAC;gBACf,CAAC;YACH,CAAC;YAED,qDAAqD;YACrD,MAAM,CAAC,QAAQ,CAAC;QAClB,CAAC;QAED;;;;;WAKG;QACK,oCAAiB,GAAzB,UAA0B,KAAa,EAAE,eAAuD;YAAvD,gCAAA,EAAA,kBAAmC,eAAe,CAAC,IAAI;YACxF,IAAA,gCAAS,CAAgB;YAC3B,IAAA,eAA8C,EAA5C,gCAAa,EAAE,kCAAc,CAAgB;YAEnD,6DAA6D;YAC7D,sCAAsC;YACtC,KAAK,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;YAE7D,4DAA4D;YAC5D,yBAAyB;YACzB,EAAE,CAAC,CAAC,KAAK,KAAK,aAAa,CAAC,CAAC,CAAC;gBAC5B,IAAI,MAAM,GAAoB,cAAc,CAAC,KAAK,CAAC,CAAC;gBAEpD,0BAA0B;gBAC1B,IAAI,CAAC,QAAQ,CAAC;oBACZ,aAAa,EAAE,KAAK;iBACrB,CAAC,CAAC;gBAEH,iDAAiD;gBACjD,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;oBACd,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;gBAC3B,CAAC;gBAED,mCAAmC;gBACnC,gCAAgC;gBAChC,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC3B,CAAC;QACH,CAAC;QAED;;;WAGG;QAEK,0BAAO,GAAf;YACE,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC;YAErC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBACxB,IAAI,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;YACnC,CAAC;QACH,CAAC;QAED;;;;WAIG;QAEK,oCAAiB,GAAzB;YADA,iBA2BC;YAzBC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBAEhC,kBAAkB;gBAClB,IAAI,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,sBAAM,IAAI,CAAC,KAAK,CAAC,cAAc,EAAG,CAAC;gBAE/E,4EAA4E;gBAC5E,qIAAqI;gBACrI,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBAC9B,IAAI,CAAC,QAAQ,CAAC;wBACZ,cAAc,EAAE,UAAU;qBAC3B,CAAC,CAAC;gBACL,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;oBAEzC,mFAAmF;oBACnF,gDAAgD;oBAChD,IAAI,SAAO,GAAmC,IAAI,CAAC,eAAe,GAAG,UAAU,CAAC;oBAChF,SAAO,CAAC,IAAI,CAAC,UAAC,qBAAwC;wBACpD,EAAE,CAAC,CAAC,SAAO,KAAK,KAAI,CAAC,eAAe,CAAC,CAAC,CAAC;4BACrC,KAAI,CAAC,QAAQ,CAAC;gCACZ,cAAc,EAAE,qBAAqB;6BACtC,CAAC,CAAC;wBACL,CAAC;oBACH,CAAC,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;QACH,CAAC;QAED;;;WAGG;QAEK,0BAAO,GAAf;YACE,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBACvB,IAAI,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,CAAC;gBAClC,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,CAAC;QACH,CAAC;QAED;;WAEG;QACK,sCAAmB,GAA3B;YACM,IAAA,eAGU,EAFZ,wBAAS,EACT,gCAAa,CACA;YACX,IAAA,eAIU,EAHZ,4CAAmB,EACnB,gEAA6B,EAC7B,kCAAc,CACD;YAEf,uDAAuD;YACvD,sBAAsB;YACtB,EAAE,CAAC,CAAC,aAAa,IAAI,mBAAmB,KAAK,EAAE,CAAC,CAAC,CAAC;gBAEhD,gDAAgD;gBAChD,EAAE,CAAC,CAAC,6BAA6B,IAAI,CAAC,CAAC,CAAC,CAAC;oBACvC,IAAI,iBAAiB,GAAW,cAAc,CAAC,6BAA6B,CAAC,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;oBAEvG,8FAA8F;oBAC9F,0FAA0F;oBAC1F,6EAA6E;oBAC7E,EAAE,CAAC,CAAC,mBAAmB,CAAC,iBAAiB,EAAE,KAAK,iBAAiB;wBAC/D,CAAC,iBAAiB,CAAC,OAAO,CAAC,mBAAmB,CAAC,iBAAiB,EAAE,CAAC,KAAK,CAAC;4BACvE,IAAI,CAAC,SAAS,CAAC,eAAe;4BAC9B,mBAAmB,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,KAAK,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBAC7H,IAAI,CAAC,iBAAiB,CAAC,6BAA6B,CAAC,CAAC;wBACtD,IAAI,CAAC,iBAAiB,EAAE,CAAC;wBACzB,MAAM,CAAC;oBACT,CAAC;gBACH,CAAC;gBAED,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;oBACd,SAAS,CAAC,SAAS,EAAE,SAAS,EAAE,mBAAmB,CAAC,CAAC;gBACvD,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,gDAAgD;oBAChD,IAAI,SAAS,GAAoB,EAAE,GAAG,EAAE,mBAAmB,EAAE,IAAI,EAAE,mBAAmB,EAAE,CAAC;oBACzF,IAAI,UAAU,GAA0B,cAAc,SAAE,SAAS,EAAC,CAAC;oBAEnE,IAAI,CAAC,QAAQ,CAAC;wBACZ,cAAc,EAAE,UAAU;wBAC1B,aAAa,EAAE,UAAU,CAAC,MAAM,GAAG,CAAC;qBACrC,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,6BAA6B,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC9C,8DAA8D;gBAC9D,6BAA6B;gBAC7B,IAAI,CAAC,iBAAiB,CAAC,6BAA6B,CAAC,CAAC;YACxD,CAAC;YAED,kCAAkC;YAClC,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC3B,CAAC;QAED,4CAA4C;QAEpC,qCAAkB,GAA1B,UAA2B,KAAqB;YAE5C,IAAA,uBAAiC,EAAjC,sDAAiC,EACjC,iCAAY,CACJ;YAEV,MAAM,CAAC,CACL,oBAAC,iBAAO,qBACN,aAAa,EAAG,KAAK,EACrB,QAAQ,EAAG,CAAC,EACZ,UAAU,EAAG,KAAK,EAClB,eAAe,EAAG,iCAAe,CAAC,cAAc,EAChD,oBAAoB,EAAG,IAAI,IACtB,YAAY,IACjB,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,OAAO,EACpC,aAAa,EAAG,IAAI,CAAC,gBAAgB,EACrC,SAAS,EAAG,IAAI,CAAC,UAAU,EAC3B,eAAe,EAAG,KAAK;gBAEvB,6BAAK,GAAG,EAAG,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,EAAG,KAAK,EAAG,EAAE,KAAK,EAAE,IAAI,CAAC,gBAAgB,CAAC,WAAW,GAAG,CAAC,EAAE,IAClG,YAAoB,sBAAM,KAAK,GAAI,IAAI,CAAC,aAAa,CAAC,CACrD,CACE,CACX,CAAC;QACJ,CAAC;QAED,uBAAuB;QAEf,gCAAa,GAArB,UAAsB,KAAqB;YAD3C,iBAmBC;YAhBG,IAAA,4BAAiC,EAAjC,sDAAiC,CACpB;YAEf,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC;YACZ,IAAA,wCAAa,CAAgB;YAEnC,MAAM,CAAC,CACL,6BACE,EAAE,EAAG,EAAE,GAAG,OAAO,EACjB,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,qBAC3B,EAAE,GAAG,QAAQ,EAC/B,IAAI,EAAC,SAAS,IAEZ,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,CAAC,UAAC,IAAI,EAAE,KAAK,IAAK,OAAA,YAAY,CAAC,qBAAK,IAAI,IAAE,KAAK,OAAA,GAAuB,EAAE,KAAI,CAAC,aAAa,CAAC,EAAzE,CAAyE,CAAC,CACvH,CACP,CAAC;QACJ,CAAC;QAED,eAAe;QAEP,gCAAa,GAArB,UAAsB,IAAqB;YAEzC,MAAM,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACtB,KAAK,qDAA4B,CAAC,OAAO;oBACvC,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;gBACrC,KAAK,qDAA4B,CAAC,MAAM;oBACtC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;gBAClC;oBACE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACpC,CAAC;QACH,CAAC;QAED,mBAAmB;QACX,mCAAgB,GAAxB,UAAyB,IAAqB;YACtC,IAAA,kBAAK,EAAE,cAAG,CAAU;YAE1B,EAAE,CAAC,CAAC,KAAK,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;gBACvB,MAAM,CAAC,6BACL,IAAI,EAAC,WAAW,EAChB,GAAG,EAAG,GAAG,EACT,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,OAAO,GAAK,CAAC;YAC9C,CAAC;YACD,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QAEO,gCAAa,GAArB,UAAsB,IAAqB;YACnC,IAAA,8BAAqC,EAArC,0DAAqC,CAAgB;YAE3D,MAAM,CAAC,CACL,6BAAK,GAAG,EAAG,IAAI,CAAC,GAAG,EAAG,SAAS,EAAG,IAAI,CAAC,WAAW,CAAC,MAAM,EAAG,IAAI,EAAC,QAAQ,IACrE,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,CACxC,CAAC,CAAC;QACZ,CAAC;QAED,mBAAmB;QAEX,gCAAa,GAArB,UAAsB,IAAqB;YAD3C,iBAuBC;YArBO,IAAA,8BAAqC,EAArC,0DAAqC,CAAgB;YAC3D,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC;YAClB,IAAI,UAAU,GAAY,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC7D,MAAM,CAAC,CACL,oBAAC,sBAAa,IACZ,EAAE,EAAG,EAAE,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,EAC9B,GAAG,EAAG,IAAI,CAAC,GAAG,gBACD,IAAI,CAAC,KAAK,EACvB,SAAS,EAAG,oBAAoB,EAChC,MAAM,EAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,EAC3C,OAAO,EAAG,UAAU,EACpB,OAAO,EAAG,cAAM,OAAA,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,EAA7B,CAA6B,EAC7C,IAAI,EAAC,QAAQ,mBACG,UAAU,GAAG,MAAM,GAAG,OAAO,EAC7C,SAAS,EAAG,IAAI,CAAC,IAAI;;gBACnB,8BAAM,GAAG,EAAG,IAAI,CAAC,WAAW,CAAC,UAAU,GAAG,kBAAkB,GAAG,EAAE,CAAC,IAClE,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,CACvC,CAES,CACjB,CAAC;QACJ,CAAC;QAED;;;;aAIK;QACG,oCAAiB,GAAzB,UAA0B,KAAyB;YAC7C,IAAA,eAIU,EAHZ,gEAA6B,EAC7B,4CAAmB,EACnB,gCAAa,CACA;YACf,MAAM,CAAC,CAAC,CAAC,6BAA6B,IAAI,CAAC,IAAI,mBAAmB,KAAK,EAAE,CAAC;gBACxE,6BAA6B,KAAK,KAAK,GAAG,aAAa,KAAK,KAAK,CAAC,CAAC;QACvE,CAAC;QAED;;WAEG;QACK,kCAAe,GAAvB;YACE,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;gBAC1B,IAAI,UAAU,GAAG,IAAI,CAAC;gBACtB,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,CAAC;oBACpC,IAAI,oBAAoB,GAAG,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,qBAAqB,EAAE,CAAC;oBACnF,IAAI,mBAAmB,GAAG,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,qBAAqB,EAAE,CAAC;oBAErF,EAAE,CAAC,CAAC,oBAAoB,CAAC,GAAG,GAAG,oBAAoB,CAAC,MAAM,IAAI,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC;wBACtF,UAAU,GAAG,KAAK,CAAC;oBACrB,CAAC;gBACH,CAAC;gBAED,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAChE,CAAC;QACH,CAAC;QAED,yBAAyB;QAEjB,kCAAe,GAAvB,UAAwB,IAAqB;YAC3C,IAAM,YAAY,GAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;YACxD,MAAM,CAAC,8BAAM,SAAS,EAAG,YAAY,CAAC,UAAoB,IAAK,IAAI,CAAC,IAAI,CAAS,CAAC;QACpF,CAAC;QAED;;;;WAIG;QACK,+BAAY,GAApB,UAAqB,KAAyB;YAC5C,IAAI,CAAC,iBAAiB,CAAC,KAAe,CAAC,CAAC;YACxC,IAAI,CAAC,QAAQ,CAAC;gBACZ,MAAM,EAAE,KAAK;aACd,CAAC,CAAC;QACL,CAAC;QAED;;WAEG;QAEK,6BAAU,GAAlB;YAEE,2BAA2B;YAC3B,0BAA0B;YAC1B,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAE3B,qCAAqC;YACrC,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;YACjC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;QACzB,CAAC;QAED;;;;;WAKG;QACK,oCAAiB,GAAzB,UAA0B,OAAsC,EAAE,WAAwC;YACxG,EAAE,CAAC,CAAC,OAAO,KAAK,SAAS,IAAI,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC;gBACvD,MAAM,CAAC,CAAC,CAAC,CAAC;YACZ,CAAC;YAED,MAAM,CAAC,qBAAS,CAAC,OAAO,EAAE,CAAC,UAAA,MAAM,IAAI,OAAA,CAAC,MAAM,CAAC,UAAU,IAAI,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,GAAG,KAAK,WAAW,CAAC,EAApE,CAAoE,CAAC,CAAC,CAAC;QAC9G,CAAC;QAED;;;;;WAKG;QACK,sCAAmB,GAA3B;YACM,IAAA,eAGU,EAFZ,gCAAa,EACb,kCAAc,CACD;YACf,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;YACvB,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAEzB,EAAE,CAAC,CAAC,aAAa,GAAG,CAAC,IAAI,aAAa,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC/D,IAAI,CAAC,QAAQ,CAAC;oBACZ,qBAAqB,EAAE,cAAc,CAAC,aAAa,CAAC,CAAC,IAAI;iBAC1D,CAAC,CAAC;YACL,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC5B,0CAA0C;gBAC1C,IAAI,CAAC,QAAQ,CAAC;oBACZ,qBAAqB,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK;iBACxC,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAED;;WAEG;QACK,oCAAiB,GAAzB;YACE,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,2BAA2B,EAAE,CAAC,CAAC,CAAC,mCAAmC,EAAE,EAAE,CAAC,yBAAyB,CAAC,CAAC;QAC7H,CAAC;QAED;;;;;WAKG;QACK,kCAAe,GAAvB,UAAwB,mBAA2B,EAAE,6BAAqC,EAAE,qBAA6B;YACvH,IAAI,CAAC,QAAQ,CAAC;gBACZ,mBAAmB,EAAE,mBAAmB;gBACxC,6BAA6B,EAAE,6BAA6B;gBAC5D,qBAAqB,EAAE,qBAAqB;aAC7C,CAAC,CAAC;QACL,CAAC;QAED;;;WAGG;QACK,2CAAwB,GAAhC,UAAiC,KAAa;YAE1C,IAAA,0CAAc,CACD;YAEf,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;gBAChD,IAAI,MAAM,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;gBACnC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;YACxD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC3B,CAAC;QAEH,CAAC;QAED;;;;;WAKG;QACK,+CAA4B,GAApC,UAAqC,KAAa,EAAE,eAAgC;YAC9E,IAAA,eAGU,EAFZ,kBAAM,EACN,gCAAa,CACA;YAEf,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACX,KAAK,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;gBAC7D,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;YACvC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,CAAC,iBAAiB,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;YACzD,CAAC;QACH,CAAC;QAED;;;WAGG;QAEK,kCAAe,GAAvB,UAAwB,EAAmD;YACrE,IAAA,eAIU,EAHZ,sBAAQ,EACR,gCAAa,EACb,8BAAY,CACC;YACX,IAAA,eAKU,EAJZ,kBAAM,EACN,gEAA6B,EAC7B,gCAAa,EACb,kCAAc,CACD;YAEf,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACb,IAAI,CAAC,wBAAwB,CAAC,EAAE,CAAC,CAAC;gBAClC,MAAM,CAAC;YACT,CAAC;YAED,IAAI,KAAK,GAAG,6BAA6B,IAAI,CAAC,GAAG,6BAA6B,GAAG,aAAa,CAAC;YAE/F,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;gBACjB;oBACE,oCAAoC;oBACpC,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAE3B,oBAAoB;oBACpB,qCAAqC;oBACrC,+BAA+B;oBAC/B,6BAA6B;oBAC7B,sBAAsB;oBACtB,EAAE,CAAC,CAAC,CAAC,MAAM;wBACT,CAAC,CAAC,CAAC,aAAa;4BACd,IAAI,CAAC,KAAK,CAAC,mBAAmB,KAAK,SAAS;4BAC5C,IAAI,CAAC,KAAK,CAAC,mBAAmB,KAAK,IAAI;4BACvC,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,MAAM,IAAI,CAAC,CAAC;4BAC3C,IAAI,CAAC,KAAK,CAAC,6BAA6B,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACnD,IAAI,CAAC,QAAQ,CAAC;4BACZ,MAAM,EAAE,CAAC,MAAM;yBAChB,CAAC,CAAC;oBACL,CAAC;oBAED,yBAAyB;oBACzB,EAAE,CAAC,CAAC,EAAE,CAAC,KAAe,gBAAiB,CAAC,CAAC,CAAC;wBACxC,MAAM,CAAC;oBACT,CAAC;oBACD,KAAK,CAAC;gBAER;oBACE,oCAAoC;oBACpC,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAE3B,kCAAkC;oBAClC,+CAA+C;oBAC/C,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;wBACX,IAAI,CAAC,QAAQ,CAAC;4BACZ,MAAM,EAAE,CAAC,MAAM;yBAChB,CAAC,CAAC;oBACL,CAAC;oBAED,yBAAyB;oBACzB,MAAM,CAAC;gBAET;oBACE,2BAA2B;oBAC3B,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAE3B,2BAA2B;oBAC3B,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;wBACX,IAAI,CAAC,QAAQ,CAAC;4BACZ,MAAM,EAAE,KAAK;yBACd,CAAC,CAAC;oBACL,CAAC;oBACD,KAAK,CAAC;gBAER;oBACE,4BAA4B;oBAC5B,IAAI,CAAC,4BAA4B,CAAC,KAAK,EAAE,eAAe,CAAC,QAAQ,CAAC,CAAC;oBACnE,KAAK,CAAC;gBAER;oBACE,yCAAyC;oBACzC,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,IAAI,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;wBAC5B,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;oBAClC,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,yBAAyB;wBACzB,IAAI,CAAC,4BAA4B,CAAC,KAAK,EAAE,eAAe,CAAC,OAAO,CAAC,CAAC;oBACpE,CAAC;oBACD,KAAK,CAAC;gBAER,mBAAmB;gBACnB;oBACE,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;wBAClB,MAAM,CAAC;oBACT,CAAC;oBAED,4CAA4C;oBAC5C,4CAA4C;oBAC5C,KAAK,GAAG,CAAC,CAAC,CAAC;oBACX,IAAI,iBAAiB,GAAG,eAAe,CAAC,OAAO,CAAC;oBAEhD,8CAA8C;oBAC9C,2CAA2C;oBAC3C,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,iBAAiB,CAAC,CAAC,CAAC;wBAC9B,KAAK,GAAG,cAAc,CAAC,MAAM,CAAC;wBAC9B,iBAAiB,GAAG,eAAe,CAAC,QAAQ,CAAC;oBAC/C,CAAC;oBAED,IAAI,CAAC,4BAA4B,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC;oBAC5D,KAAK,CAAC;gBAER;oBACE,oCAAoC;oBACpC,EAAE,CAAC,CAAC,CAAC,aAAa,IAAI,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC;wBAC7C,KAAK,CAAC;oBACR,CAAC;gBAEH;oBAEE,mDAAmD;oBACnD,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,IAAI,GAAG,CAAC,QAAQ,IAAI,EAAE,CAAC,KAAK,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;wBAC1D,MAAM,CAAC;oBACT,CAAC;oBAED,+CAA+C;oBAC/C,4DAA4D;oBAC5D,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,IAAI,EAAE,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC;wBACxC,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC;oBACrC,CAAC;oBAED,sCAAsC;oBACtC,+CAA+C;oBAC/C,6CAA6C;oBAC7C,EAAE,CAAC,CAAC,CAAC,aAAa,IAAI,YAAY,KAAK,IAAI,CAAC,CAAC,CAAC;wBAC5C,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;wBACnD,KAAK,CAAC;oBACR,CAAC;oBAED,wCAAwC;oBACxC,MAAM,CAAC;YACX,CAAC;YAED,EAAE,CAAC,eAAe,EAAE,CAAC;YACrB,EAAE,CAAC,cAAc,EAAE,CAAC;QACtB,CAAC;QAED;;;WAGG;QAEK,gCAAa,GAArB,UAAsB,EAAmD;YACnE,IAAA,eAIU,EAHZ,sBAAQ,EACR,gCAAa,EACb,8BAAY,CACC;YAEf,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACb,IAAI,CAAC,wBAAwB,CAAC,EAAE,CAAC,CAAC;gBAClC,MAAM,CAAC;YACT,CAAC;YAED,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;gBACjB;oBACE,2DAA2D;oBAC3D,0CAA0C;oBAC1C,mCAAmC;oBACnC,EAAE,CAAC,CAAC,CAAC,aAAa,IAAI,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC;wBAC7C,IAAI,CAAC,QAAQ,CAAC;4BACZ,MAAM,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM;yBAC3B,CAAC,CAAC;wBACH,MAAM,CAAC;oBACT,CAAC;oBACD,KAAK,CAAC;gBAER;oBACE,MAAM,CAAC;YACX,CAAC;YAED,EAAE,CAAC,eAAe,EAAE,CAAC;YACrB,EAAE,CAAC,cAAc,EAAE,CAAC;QACtB,CAAC;QAED;;;;WAIG;QACK,2CAAwB,GAAhC,UAAiC,EAA0D;YACzF,iDAAiD;YACjD,8CAA8C;YAC9C,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACxB,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;oBACtB,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;gBACnC,CAAC;gBAED,qDAAqD;gBACrD,6DAA6D;gBAC7D,EAAE,CAAC,CAAC,EAAE,KAAK,IAAI;oBACb,EAAE,CAAC,KAAK,gBAAiB;oBACzB,EAAE,CAAC,KAAK,oBAAoB;oBAC5B,CAAC,EAAE,CAAC,KAAK,GAAG,GAAG,CAAC,QAAQ,IAAI,EAAE,CAAC,KAAK,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;oBACxD,EAAE,CAAC,eAAe,EAAE,CAAC;oBACrB,EAAE,CAAC,cAAc,EAAE,CAAC;gBACtB,CAAC;YACH,CAAC;QACH,CAAC;QAED;;;;WAIG;QAEK,mCAAgB,GAAxB;YACQ,IAAA,8BAAQ,CAAgB;YACxB,IAAA,0BAAM,CAAgB;YAE5B,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACd,IAAI,CAAC,QAAQ,CAAC;oBACZ,MAAM,EAAE,CAAC,MAAM;iBAChB,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAED;;;SAGC;QACO,wCAAqB,GAA7B;YACU,IAAA,8DAAkD,CAAgB;YAC1E,MAAM,CAAC,0CAAwB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAM,EAAE,2BAA2B,CAAC,CAAC;QAClF,CAAC;QAED;;;WAGG;QACK,0CAAuB,GAA/B,UAAgC,IAAqB;YAC3C,IAAA,2DAA+C,CAAgB;YAC/D,IAAA,0CAAoC,CAAU;YAEtD,MAAM,CAAC,iCAAe,CAAC,IAAI,CAAC,KAAK,CAAC,KAAM,EAAE,yBAAyB,EAAE,4BAA4B,CAAC,CAAC;QACrG,CAAC;QAhrCa,qBAAY,GAAmB;YAC3C,OAAO,EAAE,EAAE;YACX,aAAa,EAAE,KAAK;YACpB,YAAY,EAAE,IAAI;YAClB,eAAe,EAAE,EAAE,QAAQ,EAAE,aAAa,EAAE;SAC7C,CAAC;QAuOF;YADC,oBAAQ;6CAKR;QAUD;YADC,oBAAQ;gFAWR;QAWD;YADC,oBAAQ;iGAGR;QAQD;YADC,oBAAQ;wDA4DR;QAoBD;YADC,oBAAQ;sDAUR;QAiMD;YADC,oBAAQ;+CAOR;QAQD;YADC,oBAAQ;yDA2BR;QAOD;YADC,oBAAQ;+CAMR;QA6DD;YADC,oBAAQ;0DAyBR;QAID;YADC,oBAAQ;qDAmBR;QAID;YADC,oBAAQ;qDAWR;QA0BD;YADC,oBAAQ;qDAuBR;QAsCD;YADC,oBAAQ;uDAIR;QAkBD;YADC,oBAAQ;kDAUR;QA0GD;YADC,oBAAQ;uDAgJR;QAOD;YADC,oBAAQ;qDAgCR;QAiCD;YADC,oBAAQ;wDAUR;QA9pCU,QAAQ;YADpB,wBAAY,CAAC,CAAC,OAAO,CAAC,CAAC;WACX,QAAQ,CAmrCpB;QAAD,eAAC;KAnrCD,AAmrCC,CAnrC6B,yBAAa,GAmrC1C;IAnrCY,4BAAQ","file":"components/ComboBox/ComboBox.js","sourcesContent":["import * as React from 'react';\r\nimport { IComboBoxOption, IComboBoxProps } from './ComboBox.Props';\r\nimport { DirectionalHint } from '../../common/DirectionalHint';\r\nimport { Callout } from '../../Callout';\r\nimport { Label } from '../../Label';\r\nimport {\r\n  CommandButton,\r\n  IconButton\r\n} from '../../Button';\r\nimport { BaseAutoFill } from '../pickers/AutoFill/BaseAutoFill';\r\nimport { IBaseAutoFillProps } from '../pickers/AutoFill/BaseAutoFill.Props';\r\nimport {\r\n  autobind,\r\n  BaseComponent,\r\n  divProperties,\r\n  findIndex,\r\n  getId,\r\n  getNativeProps,\r\n  KeyCodes,\r\n} from '../../Utilities';\r\nimport { SelectableOptionMenuItemType, ISelectableOption } from '../../utilities/selectableOption/SelectableOption.Props';\r\n\r\nimport {\r\n  customizable,\r\n} from '../../Utilities';\r\nimport {\r\n  getStyles,\r\n  getOptionStyles,\r\n  getCaretDownButtonStyles\r\n} from './ComboBox.styles';\r\nimport {\r\n  IComboBoxClassNames,\r\n  getClassNames,\r\n} from './ComboBox.classNames';\r\n\r\nexport interface IComboBoxState {\r\n\r\n  // The open state\r\n  isOpen?: boolean;\r\n\r\n  // The currently selected index (-1 if no index is selected)\r\n  selectedIndex: number;\r\n\r\n  // The focused state of the comboBox\r\n  focused?: boolean;\r\n\r\n  // This value is used for the autocomplete hint value\r\n  suggestedDisplayValue?: string;\r\n\r\n  // The options currently available for the callout\r\n  currentOptions: IComboBoxOption[];\r\n\r\n  // when taking input, this will store the index the\r\n  // that the options input matches (-1 if no input or match)\r\n  currentPendingValueValidIndex: number;\r\n\r\n  // when taking input, this will store\r\n  // the actual text that is being entered\r\n  currentPendingValue: string;\r\n}\r\n\r\nenum SearchDirection {\r\n  backward = -1,\r\n  none = 0,\r\n  forward = 1\r\n}\r\n\r\n@customizable(['theme'])\r\nexport class ComboBox extends BaseComponent<IComboBoxProps, IComboBoxState> {\r\n\r\n  public static defaultProps: IComboBoxProps = {\r\n    options: [],\r\n    allowFreeform: false,\r\n    autoComplete: 'on',\r\n    buttonIconProps: { iconName: 'ChevronDown' }\r\n  };\r\n\r\n  public refs: {\r\n    [key: string]: React.ReactInstance,\r\n    root: HTMLElement\r\n  };\r\n\r\n  // The input aspect of the comboBox\r\n  private _comboBox: BaseAutoFill;\r\n\r\n  // The wrapping div of the input and button\r\n  private _comboBoxWrapper: HTMLDivElement;\r\n\r\n  // The callout element\r\n  private _comboBoxMenu: HTMLElement;\r\n\r\n  // The menu item element that is currently selected\r\n  private _selectedElement: HTMLElement;\r\n\r\n  // The base id for the comboBox\r\n  private _id: string;\r\n\r\n  // This is used to clear any pending autocomplete\r\n  // text (used when autocomplete is true and allowFreeform is false)\r\n  private readonly _readOnlyPendingAutoCompleteTimeout: number = 1000 /* ms */;\r\n\r\n  // After a character is inserted when autocomplete is true and\r\n  // allowFreeform is false, remember the task that will clear\r\n  // the pending string of characters\r\n  private _lastReadOnlyAutoCompleteChangeTimeoutId: number;\r\n\r\n  // Promise used when resolving the comboBox options\r\n  private _currentPromise: PromiseLike<IComboBoxOption[]>;\r\n\r\n  // The current visible value sent to the auto fill on render\r\n  private _currentVisibleValue: string | undefined;\r\n\r\n  private _classNames: IComboBoxClassNames;\r\n\r\n  constructor(props: IComboBoxProps) {\r\n    super(props);\r\n\r\n    this._warnMutuallyExclusive({\r\n      'defaultSelectedKey': 'selectedKey',\r\n      'value': 'defaultSelectedKey',\r\n      'selectedKey': 'value'\r\n    });\r\n\r\n    this._id = props.id || getId('ComboBox');\r\n\r\n    let selectedKey = props.defaultSelectedKey !== undefined ? props.defaultSelectedKey : props.selectedKey;\r\n    this._lastReadOnlyAutoCompleteChangeTimeoutId = -1;\r\n\r\n    let index: number = this._getSelectedIndex(props.options, selectedKey);\r\n\r\n    this.state = {\r\n      isOpen: false,\r\n      selectedIndex: index,\r\n      focused: false,\r\n      suggestedDisplayValue: '',\r\n      currentOptions: this.props.options,\r\n      currentPendingValueValidIndex: -1,\r\n      currentPendingValue: ''\r\n    };\r\n  }\r\n\r\n  public componentDidMount() {\r\n    // hook up resolving the options if needed on focus\r\n    this._events.on(this._comboBoxWrapper, 'focus', this._onResolveOptions, true);\r\n  }\r\n\r\n  public componentWillReceiveProps(newProps: IComboBoxProps) {\r\n    // In controlled component usage where selectedKey or value is provided,\r\n    // update the selectedIndex and currentOptions state if the selectedKey or options have changed\r\n    if ((newProps.selectedKey || newProps.value) &&\r\n      (newProps.selectedKey !== this.props.selectedKey || newProps.options !== this.props.options)) {\r\n      let index: number = this._getSelectedIndex(newProps.options, newProps.selectedKey);\r\n      this.setState({\r\n        selectedIndex: index,\r\n        currentOptions: newProps.options\r\n      });\r\n    }\r\n  }\r\n\r\n  public componentDidUpdate(prevProps: IComboBoxProps, prevState: IComboBoxState) {\r\n    let {\r\n      allowFreeform,\r\n      value\r\n    } = this.props;\r\n    let {\r\n      isOpen,\r\n      focused,\r\n      selectedIndex,\r\n      currentPendingValueValidIndex\r\n    } = this.state;\r\n\r\n    // If we are newly open or are open and the pending valid index changed,\r\n    // make sure the currently selected/pending option is scrolled into view\r\n    if (isOpen &&\r\n      (!prevState.isOpen ||\r\n        prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\r\n      this._scrollIntoView();\r\n    }\r\n\r\n    // If we are open or we are focused but are not the activeElement,\r\n    // set focus on the input\r\n    if (isOpen || (focused && document.activeElement !== this._comboBox.inputElement)) {\r\n      this.focus();\r\n    }\r\n\r\n    // If we just opened/closed the menu OR\r\n    // updated the selectedIndex with the menu closed OR\r\n    // are focused and are not allowing freeform or the value changed\r\n    // we need to set selection\r\n    if (prevState.isOpen !== isOpen ||\r\n      (!isOpen && prevState.selectedIndex !== selectedIndex) ||\r\n      (focused && (!allowFreeform || value !== prevProps.value))) {\r\n      this._select();\r\n    }\r\n  }\r\n\r\n  public componentWillUnmount() {\r\n    super.componentWillUnmount();\r\n\r\n    // remove the eventHanlder that was added in componentDidMount\r\n    this._events.off(this._comboBoxWrapper);\r\n  }\r\n\r\n  // Primary Render\r\n  public render() {\r\n    let id = this._id;\r\n    let {\r\n      className,\r\n      label,\r\n      disabled,\r\n      ariaLabel,\r\n      required,\r\n      errorMessage,\r\n      onRenderContainer = this._onRenderContainer,\r\n      allowFreeform,\r\n      autoComplete,\r\n      buttonIconProps,\r\n      styles: customStyles,\r\n      theme,\r\n    } = this.props;\r\n    let { isOpen, selectedIndex, focused, suggestedDisplayValue } = this.state;\r\n    this._currentVisibleValue = this._getVisibleValue();\r\n\r\n    let divProps = getNativeProps(this.props, divProperties);\r\n\r\n    let hasErrorMessage = (errorMessage && errorMessage.length > 0) ? true : false;\r\n\r\n    this._classNames = getClassNames(\r\n      getStyles(theme!, customStyles),\r\n      className!,\r\n      !!isOpen,\r\n      !!disabled,\r\n      !!required,\r\n      !!focused,\r\n      !!allowFreeform,\r\n      !!hasErrorMessage\r\n    );\r\n\r\n    return (\r\n      <div {...divProps } ref='root' className={ this._classNames.container }>\r\n        { label && (\r\n          <Label id={ id + '-label' } required={ required } htmlFor={ id } className={ this._classNames.label }>{ label }</Label>\r\n        ) }\r\n        <div\r\n          ref={ this._resolveRef('_comboBoxWrapper') }\r\n          id={ id + 'wrapper' }\r\n          className={ this._classNames.root }\r\n        >\r\n          <BaseAutoFill\r\n            data-is-interactable={ !disabled }\r\n            ref={ this._resolveRef('_comboBox') }\r\n            id={ id + '-input' }\r\n            className={ this._classNames.input }\r\n            type='text'\r\n            key={ selectedIndex }\r\n            onFocus={ this._select }\r\n            onBlur={ this._onBlur }\r\n            onKeyDown={ this._onInputKeyDown }\r\n            onKeyUp={ this._onInputKeyUp }\r\n            onClick={ allowFreeform ? this.focus : this._onComboBoxClick }\r\n            onInputValueChange={ this._onInputChange }\r\n            aria-expanded={ isOpen }\r\n            aria-autocomplete={ (!disabled && autoComplete === 'on') }\r\n            role='combobox'\r\n            aria-readonly={ ((allowFreeform || disabled) ? null : 'true') }\r\n            readOnly={ disabled || !allowFreeform }\r\n            aria-labelledby={ (label && (id + '-label')) }\r\n            aria-label={ ((ariaLabel && !label) && ariaLabel) }\r\n            aria-describedby={ (id + '-option') }\r\n            aria-activedescendant={ (isOpen && (selectedIndex as number) >= 0 ? (id + '-list' + selectedIndex) : null) }\r\n            aria-disabled={ disabled }\r\n            aria-owns={ (id + '-list') }\r\n            spellCheck={ false }\r\n            defaultVisibleValue={ this._currentVisibleValue }\r\n            suggestedDisplayValue={ suggestedDisplayValue }\r\n            updateValueInWillReceiveProps={ this._onUpdateValueInAutoFillWillReceiveProps }\r\n            shouldSelectFullInputValueInComponentDidUpdate={ this._onShouldSelectFullInputValueInAutoFillComponentDidUpdate } />\r\n          <IconButton\r\n            className={ 'ms-ComboBox-CaretDown-button' }\r\n            styles={ this._getCaretButtonStyles() }\r\n            role='presentation'\r\n            aria-hidden='true'\r\n            tabIndex={ -1 }\r\n            onClick={ this._onComboBoxClick }\r\n            iconProps={ buttonIconProps }\r\n            disabled={ disabled } />\r\n        </div>\r\n\r\n        { isOpen && (\r\n          (onRenderContainer as any)({ ...this.props as any }, this._onRenderContainer)\r\n        ) }\r\n        {\r\n          errorMessage &&\r\n          <div\r\n            className={ this._classNames.errorMessage }>\r\n            { errorMessage }\r\n          </div>\r\n        }\r\n      </div>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set focus on the input\r\n   */\r\n  @autobind\r\n  public focus() {\r\n    if (this._comboBox) {\r\n      this._comboBox.focus();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * componentWillReceiveProps handler for the auto fill component\r\n   * Checks/updates the iput value to set, if needed\r\n   * @param {IBaseAutoFillProps} defaultVisibleValue - the defaultVisibleValue that got passed\r\n   *  in to the auto fill's componentWillReceiveProps\r\n   * @returns {string} - the updated value to set, if needed\r\n   */\r\n  @autobind\r\n  private _onUpdateValueInAutoFillWillReceiveProps(): string | null {\r\n    if (this._comboBox === null || this._comboBox === undefined) {\r\n      return null;\r\n    }\r\n\r\n    if (this._currentVisibleValue && this._currentVisibleValue !== '' && this._comboBox.value !== this._currentVisibleValue) {\r\n      return this._currentVisibleValue;\r\n    }\r\n\r\n    return this._comboBox.value;\r\n  }\r\n\r\n  /**\r\n   * componentDidUpdate handler for the auto fill component\r\n   *\r\n   * @param { string } defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\r\n   * @param { string } suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\r\n   * @returns {boolean} - should the full value of the input be selected?\r\n   * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\r\n   */\r\n  @autobind\r\n  private _onShouldSelectFullInputValueInAutoFillComponentDidUpdate(): boolean {\r\n    return this._currentVisibleValue === this.state.suggestedDisplayValue;\r\n  }\r\n\r\n  /**\r\n   * Get the correct value to pass to the input\r\n   * to show to the user based off of the current props and state\r\n   * @returns {string} the value to pass to the input\r\n   */\r\n  @autobind\r\n  private _getVisibleValue(): string | undefined {\r\n    let {\r\n      value,\r\n      allowFreeform,\r\n      autoComplete\r\n    } = this.props;\r\n    let {\r\n      selectedIndex,\r\n      currentPendingValueValidIndex,\r\n      currentOptions,\r\n      currentPendingValue,\r\n      suggestedDisplayValue,\r\n      isOpen\r\n    } = this.state;\r\n\r\n    let currentPendingIndexValid = this._indexWithinBounds(currentOptions, currentPendingValueValidIndex);\r\n\r\n    // If the user passed is a value prop, use that\r\n    // unless we are open and have a valid current pending index\r\n    if (!(isOpen && currentPendingIndexValid) && value) {\r\n      return value;\r\n    }\r\n\r\n    let index = selectedIndex;\r\n\r\n    if (allowFreeform) {\r\n\r\n      // If we are allowing freeform and autocomplete is also true\r\n      // and we've got a pending value that matches an option, remember\r\n      // the matched option's index\r\n      if (autoComplete === 'on' && currentPendingIndexValid) {\r\n        index = currentPendingValueValidIndex;\r\n      }\r\n\r\n      // Since we are allowing freeform, if there is currently a nonempty pending value, use that\r\n      // otherwise use the index determined above (falling back to '' if we did not get a valid index)\r\n      return currentPendingValue !== '' ? currentPendingValue :\r\n        (this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : '');\r\n    } else {\r\n\r\n      // If we are not allowing freeform and have a\r\n      // valid index that matches the pending value,\r\n      // we know we will need some version of the pending value\r\n      if (currentPendingIndexValid) {\r\n\r\n        // If autoComplete is on, return the\r\n        // raw pending value, otherwise remember\r\n        // the matched option's index\r\n        if (autoComplete === 'on') {\r\n          return currentPendingValue;\r\n        }\r\n\r\n        index = currentPendingValueValidIndex;\r\n      }\r\n\r\n      // If we have a valid index then return the text value of that option,\r\n      // otherwise return the suggestedDisplayValue\r\n      return this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : suggestedDisplayValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Is the index within the bounds of the array?\r\n   * @param options - options to check if the index is valid for\r\n   * @param index - the index to check\r\n   * @returns {boolean} - true if the index is valid for the given options, false otherwise\r\n   */\r\n  private _indexWithinBounds(options: IComboBoxOption[] | undefined, index: number): boolean {\r\n    if (!options) {\r\n      return false;\r\n    }\r\n    return index >= 0 && index < options.length;\r\n  }\r\n\r\n  /**\r\n   * Handler for typing changes on the input\r\n   * @param updatedValue - the newly changed value\r\n   */\r\n  @autobind\r\n  private _onInputChange(updatedValue: string) {\r\n    if (this.props.disabled) {\r\n      this._handleInputWhenDisabled(null /* event */);\r\n      return;\r\n    }\r\n\r\n    this.props.allowFreeform ?\r\n      this._processInputChangeWithFreeform(updatedValue) :\r\n      this._processInputChangeWithoutFreeform(updatedValue);\r\n  }\r\n\r\n  /**\r\n   * Process the new input's new value when the comboBox\r\n   * allows freeform entry\r\n   * @param updatedValue - the input's newly changed value\r\n   */\r\n  private _processInputChangeWithFreeform(updatedValue: string) {\r\n    let {\r\n      currentOptions\r\n    } = this.state;\r\n\r\n    // if the new value is empty, nothing needs to be done\r\n    if (updatedValue === '') {\r\n      return;\r\n    }\r\n\r\n    // Remember the original value and then,\r\n    // make the value lowercase for comparison\r\n    let originalUpdatedValue: string = updatedValue;\r\n    updatedValue = updatedValue.toLocaleLowerCase();\r\n\r\n    let newSuggestedDisplayValue = '';\r\n    let newCurrentPendingValueValidIndex = -1;\r\n\r\n    // If autoComplete is on, attempt to find a match from the available options\r\n    if (this.props.autoComplete === 'on') {\r\n\r\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\r\n      let items = currentOptions.map((item, index) => { return { ...item, index }; }).filter((option) => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider).filter((option) => option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);\r\n      if (items.length > 0) {\r\n        // If the user typed out the complete option text, we don't need any suggested display text anymore\r\n        newSuggestedDisplayValue = items[0].text.toLocaleLowerCase() !== updatedValue ? items[0].text : '';\r\n\r\n        // remember the index of the match we found\r\n        newCurrentPendingValueValidIndex = items[0].index;\r\n      }\r\n    } else {\r\n\r\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\r\n      let items = currentOptions.map((item, index) => { return { ...item, index }; }).filter((option) => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider).filter((option) => option.text.toLocaleLowerCase() === updatedValue);\r\n\r\n      // if we fould a match remember the index\r\n      if (items.length === 1) {\r\n        newCurrentPendingValueValidIndex = items[0].index;\r\n      }\r\n    }\r\n\r\n    // Set the updated state\r\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\r\n  }\r\n\r\n  /**\r\n   * Process the new input's new value when the comboBox\r\n   * does not allow freeform entry\r\n   * @param updatedValue - the input's newly changed value\r\n   */\r\n  private _processInputChangeWithoutFreeform(updatedValue: string) {\r\n    let {\r\n      currentPendingValue,\r\n      currentPendingValueValidIndex,\r\n      currentOptions,\r\n      selectedIndex\r\n    } = this.state;\r\n\r\n    if (this.props.autoComplete === 'on') {\r\n\r\n      // If autoComplete is on while allow freeform is off,\r\n      // we will remember the keypresses and build up a string to attempt to match\r\n      // as long as characters are typed within a the timeout span of each other,\r\n      // otherwise we will clear the string and start building a new one on the next keypress.\r\n      // Also, only do this processing if we have a non-empty value\r\n      if (updatedValue !== '') {\r\n\r\n        // If we have a pending autocomplete clearing task,\r\n        // we know that the user is typing with keypresses happening\r\n        // within the timeout of each other so remove the clearing task\r\n        // and continue building the pending value with the udpated value\r\n        if (this._lastReadOnlyAutoCompleteChangeTimeoutId > 0) {\r\n          this._async.clearTimeout(this._lastReadOnlyAutoCompleteChangeTimeoutId);\r\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = -1;\r\n          updatedValue = currentPendingValue + updatedValue;\r\n        }\r\n\r\n        let originalUpdatedValue: string = updatedValue;\r\n        updatedValue = updatedValue.toLocaleLowerCase();\r\n\r\n        // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\r\n        let items = currentOptions.map((item, i) => { return { ...item, index: i }; }).filter((option) => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider).filter((option) => option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);\r\n\r\n        // If we found a match, udpdate the state\r\n        if (items.length > 0) {\r\n          this._setPendingInfo(originalUpdatedValue, items[0].index, items[0].text);\r\n        }\r\n\r\n        // Schedule a timeout to clear the pending value after the timeout span\r\n        this._lastReadOnlyAutoCompleteChangeTimeoutId =\r\n          this._async.setTimeout(\r\n            () => { this._lastReadOnlyAutoCompleteChangeTimeoutId = -1; },\r\n            this._readOnlyPendingAutoCompleteTimeout\r\n          );\r\n        return;\r\n      }\r\n    }\r\n\r\n    // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\r\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\r\n    // use that; otherwise use the selectedIndex\r\n    let index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : selectedIndex;\r\n\r\n    // Since we are not allowing freeform, we need to\r\n    // set both the pending and suggested values/index\r\n    // to allow us to select all content in the input to\r\n    // give the illusion that we are readonly (e.g. freeform off)\r\n    this._setPendingInfoFromIndex(index);\r\n  }\r\n\r\n  /**\r\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\r\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\r\n   * @param index - the index to get the next selectable index from\r\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\r\n   * @returns {number} - the next valid selectable index. If the new index is outside of the bounds,\r\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\r\n   */\r\n  private _getNextSelectableIndex(index: number, searchDirection: SearchDirection): number {\r\n    let { currentOptions } = this.state;\r\n\r\n    let newIndex = index + searchDirection;\r\n\r\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\r\n\r\n    let option: IComboBoxOption = currentOptions[newIndex];\r\n\r\n    // attempt to skip headers and dividers\r\n    if ((option.itemType === SelectableOptionMenuItemType.Header ||\r\n      option.itemType === SelectableOptionMenuItemType.Divider)) {\r\n\r\n      // Should we continue looking for an index to select?\r\n      if (searchDirection !== SearchDirection.none &&\r\n        ((newIndex !== 0 && searchDirection < SearchDirection.none) ||\r\n          (newIndex !== currentOptions.length - 1 && searchDirection > SearchDirection.none))) {\r\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\r\n      } else {\r\n        // If we cannot perform a useful search just return the index we were given\r\n        return index;\r\n      }\r\n    }\r\n\r\n    // We have the next valid selectable index, return it\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Set the selected index. Note, this is\r\n   * the \"real\" selected index, not the pending selected index\r\n   * @param index - the index to set (or the index to set from if a search direction is provided)\r\n   * @param searchDirection - the direction to search along the options from the given index\r\n   */\r\n  private _setSelectedIndex(index: number, searchDirection: SearchDirection = SearchDirection.none) {\r\n    let { onChanged } = this.props;\r\n    let { selectedIndex, currentOptions } = this.state;\r\n\r\n    // Find the next selectable index, if searchDirection is none\r\n    // we will get our starting index back\r\n    index = this._getNextSelectableIndex(index, searchDirection);\r\n\r\n    // Are we at a new index? If so, update the state, otherwise\r\n    // there is nothing to do\r\n    if (index !== selectedIndex) {\r\n      let option: IComboBoxOption = currentOptions[index];\r\n\r\n      // Set the selected option\r\n      this.setState({\r\n        selectedIndex: index\r\n      });\r\n\r\n      // Did the creator give us an onChanged callback?\r\n      if (onChanged) {\r\n        onChanged(option, index);\r\n      }\r\n\r\n      // if we have a new selected index,\r\n      // clear all of the pending info\r\n      this._clearPendingInfo();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Focus (and select) the content of the input\r\n   * and set the focused state\r\n   */\r\n  @autobind\r\n  private _select() {\r\n    this._comboBox.inputElement.select();\r\n\r\n    if (!this.state.focused) {\r\n      this.setState({ focused: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback issued when the options should be resolved, if they have been updated or\r\n   * if they need to be passed in the first time. This only does work if an onResolveOptions\r\n   * callback was passed in\r\n   */\r\n  @autobind\r\n  private _onResolveOptions() {\r\n    if (this.props.onResolveOptions) {\r\n\r\n      // get the options\r\n      let newOptions = this.props.onResolveOptions({ ...this.state.currentOptions });\r\n\r\n      // Check to see if the returned value is an array, if it is update the state\r\n      // If the returned value is not an array then check to see if it's a promise or PromiseLike. If it is then resolve it asynchronously.\r\n      if (Array.isArray(newOptions)) {\r\n        this.setState({\r\n          currentOptions: newOptions\r\n        });\r\n      } else if (newOptions && newOptions.then) {\r\n\r\n        // Ensure that the promise will only use the callback if it was the most recent one\r\n        // and update the state when the promise returns\r\n        let promise: PromiseLike<IComboBoxOption[]> = this._currentPromise = newOptions;\r\n        promise.then((newOptionsFromPromise: IComboBoxOption[]) => {\r\n          if (promise === this._currentPromise) {\r\n            this.setState({\r\n              currentOptions: newOptionsFromPromise\r\n            });\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * OnBlur handler. Set the focused state to false\r\n   * and submit any pending value\r\n   */\r\n  @autobind\r\n  private _onBlur() {\r\n    if (this.state.focused) {\r\n      this.setState({ focused: false });\r\n      this._submitPendingValue();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Submit a pending value if there is one\r\n   */\r\n  private _submitPendingValue() {\r\n    let {\r\n      onChanged,\r\n      allowFreeform\r\n    } = this.props;\r\n    let {\r\n      currentPendingValue,\r\n      currentPendingValueValidIndex,\r\n      currentOptions\r\n    } = this.state;\r\n\r\n    // If we allow freeform and we have a pending value, we\r\n    // need to handle that\r\n    if (allowFreeform && currentPendingValue !== '') {\r\n\r\n      // Check to see if the user typed an exact match\r\n      if (currentPendingValueValidIndex >= 0) {\r\n        let pendingOptionText: string = currentOptions[currentPendingValueValidIndex].text.toLocaleLowerCase();\r\n\r\n        // By exact match, that means: our pending value is the same as the the pending option text OR\r\n        // the peding option starts with the pending value and we have an \"autoComplete\" selection\r\n        // where the total lenght is equal to pending option length; update the state\r\n        if (currentPendingValue.toLocaleLowerCase() === pendingOptionText ||\r\n          (pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&\r\n            this._comboBox.isValueSelected &&\r\n            currentPendingValue.length + (this._comboBox.selectionEnd - this._comboBox.selectionStart) === pendingOptionText.length)) {\r\n          this._setSelectedIndex(currentPendingValueValidIndex);\r\n          this._clearPendingInfo();\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (onChanged) {\r\n        onChanged(undefined, undefined, currentPendingValue);\r\n      } else {\r\n        // If we are not controlled, create a new option\r\n        let newOption: IComboBoxOption = { key: currentPendingValue, text: currentPendingValue };\r\n        let newOptions: IComboBoxOption[] = [...currentOptions, newOption];\r\n\r\n        this.setState({\r\n          currentOptions: newOptions,\r\n          selectedIndex: newOptions.length - 1\r\n        });\r\n      }\r\n    } else if (currentPendingValueValidIndex >= 0) {\r\n      // Since we are not allowing freeform, we must have a matching\r\n      // to be able to update state\r\n      this._setSelectedIndex(currentPendingValueValidIndex);\r\n    }\r\n\r\n    // Finally, clear the pending info\r\n    this._clearPendingInfo();\r\n  }\r\n\r\n  // Render Callout container and pass in list\r\n  @autobind\r\n  private _onRenderContainer(props: IComboBoxProps): JSX.Element {\r\n    let {\r\n      onRenderList = this._onRenderList,\r\n      calloutProps\r\n    } = props;\r\n\r\n    return (\r\n      <Callout\r\n        isBeakVisible={ false }\r\n        gapSpace={ 0 }\r\n        doNotLayer={ false }\r\n        directionalHint={ DirectionalHint.bottomLeftEdge }\r\n        directionalHintFixed={ true }\r\n        { ...calloutProps }\r\n        className={ this._classNames.callout }\r\n        targetElement={ this._comboBoxWrapper }\r\n        onDismiss={ this._onDismiss }\r\n        setInitialFocus={ false }\r\n      >\r\n        <div ref={ this._resolveRef('_comboBoxMenu') } style={ { width: this._comboBoxWrapper.clientWidth - 2 } }>\r\n          { (onRenderList as any)({ ...props }, this._onRenderList) }\r\n        </div>\r\n      </Callout>\r\n    );\r\n  }\r\n\r\n  // Render List of items\r\n  @autobind\r\n  private _onRenderList(props: IComboBoxProps): JSX.Element {\r\n    let {\r\n      onRenderItem = this._onRenderItem\r\n    } = this.props;\r\n\r\n    let id = this._id;\r\n    let { selectedIndex } = this.state;\r\n\r\n    return (\r\n      <div\r\n        id={ id + '-list' }\r\n        className={ this._classNames.optionsContainer }\r\n        aria-labelledby={ id + '-label' }\r\n        role='listbox'\r\n      >\r\n        { this.state.currentOptions.map((item, index) => onRenderItem({ ...item, index } as ISelectableOption, this._onRenderItem)) }\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Render items\r\n  @autobind\r\n  private _onRenderItem(item: IComboBoxOption): JSX.Element | null {\r\n\r\n    switch (item.itemType) {\r\n      case SelectableOptionMenuItemType.Divider:\r\n        return this._renderSeparator(item);\r\n      case SelectableOptionMenuItemType.Header:\r\n        return this._renderHeader(item);\r\n      default:\r\n        return this._renderOption(item);\r\n    }\r\n  }\r\n\r\n  // Render separator\r\n  private _renderSeparator(item: IComboBoxOption): JSX.Element | null {\r\n    let { index, key } = item;\r\n\r\n    if (index && index > 0) {\r\n      return <div\r\n        role='separator'\r\n        key={ key }\r\n        className={ this._classNames.divider } />;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private _renderHeader(item: IComboBoxOption): JSX.Element {\r\n    let { onRenderOption = this._onRenderOption } = this.props;\r\n\r\n    return (\r\n      <div key={ item.key } className={ this._classNames.header } role='header'>\r\n        { onRenderOption(item, this._onRenderOption) }\r\n      </div>);\r\n  }\r\n\r\n  // Render menu item\r\n  @autobind\r\n  private _renderOption(item: IComboBoxOption): JSX.Element {\r\n    let { onRenderOption = this._onRenderOption } = this.props;\r\n    let id = this._id;\r\n    let isSelected: boolean = this._isOptionSelected(item.index);\r\n    return (\r\n      <CommandButton\r\n        id={ id + '-list' + item.index }\r\n        key={ item.key }\r\n        data-index={ item.index }\r\n        className={ 'ms-ComboBox-option' }\r\n        styles={ this._getCurrentOptionStyles(item) }\r\n        checked={ isSelected }\r\n        onClick={ () => this._onItemClick(item.index) }\r\n        role='option'\r\n        aria-selected={ isSelected ? 'true' : 'false' }\r\n        ariaLabel={ item.text }\r\n      > { <span ref={ this._resolveRef(isSelected ? '_selectedElement' : '') }>\r\n        { onRenderOption(item, this._onRenderOption) }\r\n      </span>\r\n        }\r\n      </CommandButton>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Use the current valid pending index if it exists OR\r\n   * we do not have a valid index and we currently have a pending input value,\r\n   * otherwise use the selected index\r\n   * */\r\n  private _isOptionSelected(index: number | undefined): boolean {\r\n    let {\r\n      currentPendingValueValidIndex,\r\n      currentPendingValue,\r\n      selectedIndex\r\n    } = this.state;\r\n    return ((currentPendingValueValidIndex >= 0 || currentPendingValue !== '') ?\r\n      currentPendingValueValidIndex === index : selectedIndex === index);\r\n  }\r\n\r\n  /**\r\n   * Scroll the selected element into view\r\n   */\r\n  private _scrollIntoView() {\r\n    if (this._selectedElement) {\r\n      let alignToTop = true;\r\n      if (this._comboBoxMenu.offsetParent) {\r\n        let scrollableParentRect = this._comboBoxMenu.offsetParent.getBoundingClientRect();\r\n        let selectedElementRect = this._selectedElement.offsetParent.getBoundingClientRect();\r\n\r\n        if (scrollableParentRect.top + scrollableParentRect.height <= selectedElementRect.top) {\r\n          alignToTop = false;\r\n        }\r\n      }\r\n\r\n      this._selectedElement.offsetParent.scrollIntoView(alignToTop);\r\n    }\r\n  }\r\n\r\n  // Render content of item\r\n  @autobind\r\n  private _onRenderOption(item: IComboBoxOption): JSX.Element {\r\n    const optionStyles = this._getCurrentOptionStyles(item);\r\n    return <span className={ optionStyles.optionText as string }>{ item.text }</span>;\r\n  }\r\n\r\n  /**\r\n   * Click handler for the menu items\r\n   * to select the item and also close the menu\r\n   * @param index - the index of the item that was clicked\r\n   */\r\n  private _onItemClick(index: number | undefined) {\r\n    this._setSelectedIndex(index as number);\r\n    this.setState({\r\n      isOpen: false\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles dismissing (cancelling) the menu\r\n   */\r\n  @autobind\r\n  private _onDismiss() {\r\n\r\n    // reset the selected index\r\n    // to the last valud state\r\n    this._resetSelectedIndex();\r\n\r\n    // close the menu and focus the input\r\n    this.setState({ isOpen: false });\r\n    this._comboBox.focus();\r\n  }\r\n\r\n  /**\r\n   * Get the index of the option that is marked as selected\r\n   * @param options - the comboBox options\r\n   * @param selectedKey - the known selected key to find\r\n   * @returns {number} - the index of the selected option, -1 if not found\r\n   */\r\n  private _getSelectedIndex(options: IComboBoxOption[] | undefined, selectedKey: string | number | undefined): number {\r\n    if (options === undefined || selectedKey === undefined) {\r\n      return -1;\r\n    }\r\n\r\n    return findIndex(options, (option => (option.isSelected || option.selected || option.key === selectedKey)));\r\n  }\r\n\r\n  /**\r\n   * Reset the selected index by clearing the\r\n   * input (of any pending text), clearing the pending state,\r\n   * and setting the suggested display value to the last\r\n   * selected state text\r\n   */\r\n  private _resetSelectedIndex() {\r\n    let {\r\n      selectedIndex,\r\n      currentOptions\r\n    } = this.state;\r\n    this._comboBox.clear();\r\n    this._clearPendingInfo();\r\n\r\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\r\n      this.setState({\r\n        suggestedDisplayValue: currentOptions[selectedIndex].text\r\n      });\r\n    } else if (this.props.value) {\r\n      // If we had a value initially, restore it\r\n      this.setState({\r\n        suggestedDisplayValue: this.props.value\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the pending info state\r\n   */\r\n  private _clearPendingInfo() {\r\n    this._setPendingInfo('' /* suggestedDisplayValue */, -1 /* currentPendingValueValidIndex */, '' /* currentPendingValue */);\r\n  }\r\n\r\n  /**\r\n   * Set the pending info\r\n   * @param currentPendingValue - new pending value to set\r\n   * @param currentPendingValueValidIndex - new pending value index to set\r\n   * @param suggestedDisplayValue - new suggest display value to set\r\n   */\r\n  private _setPendingInfo(currentPendingValue: string, currentPendingValueValidIndex: number, suggestedDisplayValue: string) {\r\n    this.setState({\r\n      currentPendingValue: currentPendingValue,\r\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\r\n      suggestedDisplayValue: suggestedDisplayValue\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set the pending info from the given index\r\n   * @param index - the index to set the pending info from\r\n   */\r\n  private _setPendingInfoFromIndex(index: number) {\r\n    let {\r\n      currentOptions\r\n    } = this.state;\r\n\r\n    if (index >= 0 && index < currentOptions.length) {\r\n      let option = currentOptions[index];\r\n      this._setPendingInfo(option.text, index, option.text);\r\n    } else {\r\n      this._clearPendingInfo();\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Sets either the pending info or the\r\n   * selected index depending of if the comboBox is open\r\n   * @param index - the index to search from\r\n   * @param searchDirection - the direction to search\r\n   */\r\n  private _setInfoForIndexAndDirection(index: number, searchDirection: SearchDirection) {\r\n    let {\r\n      isOpen,\r\n      selectedIndex\r\n    } = this.state;\r\n\r\n    if (isOpen) {\r\n      index = this._getNextSelectableIndex(index, searchDirection);\r\n      this._setPendingInfoFromIndex(index);\r\n    } else {\r\n      this._setSelectedIndex(selectedIndex, searchDirection);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle keydown on the input\r\n   * @param ev - The keyboard event that was fired\r\n   */\r\n  @autobind\r\n  private _onInputKeyDown(ev: React.KeyboardEvent<HTMLElement | BaseAutoFill>) {\r\n    let {\r\n      disabled,\r\n      allowFreeform,\r\n      autoComplete\r\n    } = this.props;\r\n    let {\r\n      isOpen,\r\n      currentPendingValueValidIndex,\r\n      selectedIndex,\r\n      currentOptions\r\n    } = this.state;\r\n\r\n    if (disabled) {\r\n      this._handleInputWhenDisabled(ev);\r\n      return;\r\n    }\r\n\r\n    let index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : selectedIndex;\r\n\r\n    switch (ev.which) {\r\n      case KeyCodes.enter:\r\n        // On enter submit the pending value\r\n        this._submitPendingValue();\r\n\r\n        // if we are open or\r\n        // if we are not allowing freeform or\r\n        // our we have no pending value\r\n        // and no valid pending index\r\n        // flip the open state\r\n        if ((isOpen ||\r\n          ((!allowFreeform ||\r\n            this.state.currentPendingValue === undefined ||\r\n            this.state.currentPendingValue === null ||\r\n            this.state.currentPendingValue.length <= 0) &&\r\n            this.state.currentPendingValueValidIndex < 0))) {\r\n          this.setState({\r\n            isOpen: !isOpen\r\n          });\r\n        }\r\n\r\n        // Allow TAB to propigate\r\n        if (ev.which as number === KeyCodes.tab) {\r\n          return;\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.tab:\r\n        // On enter submit the pending value\r\n        this._submitPendingValue();\r\n\r\n        // If we are not allowing freeform\r\n        // or the comboBox is open, flip the open state\r\n        if (isOpen) {\r\n          this.setState({\r\n            isOpen: !isOpen\r\n          });\r\n        }\r\n\r\n        // Allow TAB to propigate\r\n        return;\r\n\r\n      case KeyCodes.escape:\r\n        // reset the selected index\r\n        this._resetSelectedIndex();\r\n\r\n        // Close the menu if opened\r\n        if (isOpen) {\r\n          this.setState({\r\n            isOpen: false\r\n          });\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.up:\r\n        // Go to the previous option\r\n        this._setInfoForIndexAndDirection(index, SearchDirection.backward);\r\n        break;\r\n\r\n      case KeyCodes.down:\r\n        // Expand the comboBox on ALT + DownArrow\r\n        if (ev.altKey || ev.metaKey) {\r\n          this.setState({ isOpen: true });\r\n        } else {\r\n          // Got to the next option\r\n          this._setInfoForIndexAndDirection(index, SearchDirection.forward);\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.home:\r\n      case KeyCodes.end:\r\n        if (allowFreeform) {\r\n          return;\r\n        }\r\n\r\n        // Set the initial values to respond to HOME\r\n        // which goes to the first selectable option\r\n        index = -1;\r\n        let directionToSearch = SearchDirection.forward;\r\n\r\n        // If end, update the values to respond to END\r\n        // which goes to the last selectable option\r\n        if (ev.which === KeyCodes.end) {\r\n          index = currentOptions.length;\r\n          directionToSearch = SearchDirection.backward;\r\n        }\r\n\r\n        this._setInfoForIndexAndDirection(index, directionToSearch);\r\n        break;\r\n\r\n      case KeyCodes.space:\r\n        // event handled in _onComboBoxKeyUp\r\n        if (!allowFreeform && autoComplete === 'off') {\r\n          break;\r\n        }\r\n\r\n      default:\r\n\r\n        // are we processing a function key? if so bail out\r\n        if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\r\n          return;\r\n        }\r\n\r\n        // If we get here and we got either and ALT key\r\n        // or meta key and we are current open, let's close the menu\r\n        if ((ev.altKey || ev.metaKey) && isOpen) {\r\n          this.setState({ isOpen: !isOpen });\r\n        }\r\n\r\n        // If we are not allowing freeform and\r\n        // allowing autoComplete, handle the input here\r\n        // since we have marked the input as readonly\r\n        if (!allowFreeform && autoComplete === 'on') {\r\n          this._onInputChange(String.fromCharCode(ev.which));\r\n          break;\r\n        }\r\n\r\n        // allow the key to propigate by default\r\n        return;\r\n    }\r\n\r\n    ev.stopPropagation();\r\n    ev.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Handle keyup on the input\r\n   * @param ev - the keyboard event that was fired\r\n   */\r\n  @autobind\r\n  private _onInputKeyUp(ev: React.KeyboardEvent<HTMLElement | BaseAutoFill>) {\r\n    let {\r\n      disabled,\r\n      allowFreeform,\r\n      autoComplete\r\n    } = this.props;\r\n\r\n    if (disabled) {\r\n      this._handleInputWhenDisabled(ev);\r\n      return;\r\n    }\r\n\r\n    switch (ev.which) {\r\n      case KeyCodes.space:\r\n        // If we are not allowing freeform and are not autoComplete\r\n        // make space expand/collapse the comboBox\r\n        // and allow the event to propagate\r\n        if (!allowFreeform && autoComplete === 'off') {\r\n          this.setState({\r\n            isOpen: !this.state.isOpen\r\n          });\r\n          return;\r\n        }\r\n        break;\r\n\r\n      default:\r\n        return;\r\n    }\r\n\r\n    ev.stopPropagation();\r\n    ev.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * Handle dismissing the menu and\r\n   * eating the required key event when disabled\r\n   * @param ev - the keyboard event that was fired\r\n   */\r\n  private _handleInputWhenDisabled(ev: React.KeyboardEvent<HTMLElement | BaseAutoFill> | null) {\r\n    // If we are disabled, close the menu (if needed)\r\n    // and eat all keystokes other than TAB or ESC\r\n    if (this.props.disabled) {\r\n      if (this.state.isOpen) {\r\n        this.setState({ isOpen: false });\r\n      }\r\n\r\n      // When disabled stop propagation and prevent default\r\n      // of the event unless we have a tab, escape, or function key\r\n      if (ev !== null &&\r\n        ev.which !== KeyCodes.tab &&\r\n        ev.which !== KeyCodes.escape &&\r\n        (ev.which < 112 /* F1 */ || ev.which > 123 /* F12 */)) {\r\n        ev.stopPropagation();\r\n        ev.preventDefault();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Click handler for the button of the comboBox\r\n   * and the input when not allowing freeform. This\r\n   * toggles the expand/collapse state of the comboBox (if enbled)\r\n   */\r\n  @autobind\r\n  private _onComboBoxClick() {\r\n    let { disabled } = this.props;\r\n    let { isOpen } = this.state;\r\n\r\n    if (!disabled) {\r\n      this.setState({\r\n        isOpen: !isOpen\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n * Get the styles for the current option.\r\n * @param item Item props for the current option\r\n */\r\n  private _getCaretButtonStyles() {\r\n    const { caretDownButtonStyles: customCaretDownButtonStyles } = this.props;\r\n    return getCaretDownButtonStyles(this.props.theme!, customCaretDownButtonStyles);\r\n  }\r\n\r\n  /**\r\n   * Get the styles for the current option.\r\n   * @param item Item props for the current option\r\n   */\r\n  private _getCurrentOptionStyles(item: IComboBoxOption) {\r\n    const { comboBoxOptionStyles: customStylesForAllOptions } = this.props;\r\n    const { styles: customStylesForCurrentOption } = item;\r\n\r\n    return getOptionStyles(this.props.theme!, customStylesForAllOptions, customStylesForCurrentOption);\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\..\\src"}